


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SerialDate</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jfree.chart.date</a>
</div>

<h1>Coverage Summary for Class: SerialDate (org.jfree.chart.date)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SerialDate</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26,5%
  </span>
  <span class="absValue">
    (9/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29,7%
  </span>
  <span class="absValue">
    (44/148)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* ===========================================================
&nbsp; * JFreeChart : a free chart library for the Java(tm) platform
&nbsp; * ===========================================================
&nbsp; *
&nbsp; * (C) Copyright 2000-2022, by David Gilbert and Contributors.
&nbsp; *
&nbsp; * Project Info:  http://www.jfree.org/jfreechart/index.html
&nbsp; *
&nbsp; * This library is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU Lesser General Public License as published by
&nbsp; * the Free Software Foundation; either version 2.1 of the License, or
&nbsp; * (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful, but
&nbsp; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
&nbsp; * License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
&nbsp; * USA.
&nbsp; *
&nbsp; * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. 
&nbsp; * Other names may be trademarks of their respective owners.]
&nbsp; *
&nbsp; * ---------------
&nbsp; * SerialDate.java
&nbsp; * ---------------
&nbsp; * (C) Copyright 2006-2022, by David Gilbert and Contributors.
&nbsp; *
&nbsp; * Original Author:  David Gilbert;
&nbsp; * Contributor(s):   -;
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.jfree.chart.date;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.text.DateFormatSymbols;
&nbsp;import java.text.SimpleDateFormat;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.GregorianCalendar;
&nbsp;
&nbsp;/**
&nbsp; *  An abstract class that defines our requirements for manipulating dates,
&nbsp; *  without tying down a particular implementation.
&nbsp; *  &lt;P&gt;
&nbsp; *  Requirement 1 : match at least what Excel does for dates;
&nbsp; *  Requirement 2 : the date represented by the class is immutable;
&nbsp; *  &lt;P&gt;
&nbsp; *  Why not just use java.util.Date?  We will, when it makes sense.  At times,
&nbsp; *  java.util.Date can be *too* precise - it represents an instant in time,
&nbsp; *  accurate to 1/1000th of a second (with the date itself depending on the
&nbsp; *  time-zone).  Sometimes we just want to represent a particular day (e.g. 21
&nbsp; *  January 2015) without concerning ourselves about the time of day, or the
&nbsp; *  time-zone, or anything else.  That&#39;s what we&#39;ve defined SerialDate for.
&nbsp; *  &lt;P&gt;
&nbsp; *  You can call getInstance() to get a concrete subclass of SerialDate,
&nbsp; *  without worrying about the exact implementation.
&nbsp; */
&nbsp;public abstract class SerialDate implements Comparable, Serializable, 
&nbsp;        MonthConstants {
&nbsp;
&nbsp;    /** For serialization. */
&nbsp;    private static final long serialVersionUID = -293716040467423637L;
&nbsp;    
&nbsp;    /** Date format symbols. */
&nbsp;    public static final DateFormatSymbols
<b class="fc">&nbsp;        DATE_FORMAT_SYMBOLS = new SimpleDateFormat().getDateFormatSymbols();</b>
&nbsp;
&nbsp;    /** The serial number for 1 January 1900. */
&nbsp;    public static final int SERIAL_LOWER_BOUND = 2;
&nbsp;
&nbsp;    /** The serial number for 31 December 9999. */
&nbsp;    public static final int SERIAL_UPPER_BOUND = 2958465;
&nbsp;
&nbsp;    /** The lowest year value supported by this date format. */
&nbsp;    public static final int MINIMUM_YEAR_SUPPORTED = 1900;
&nbsp;
&nbsp;    /** The highest year value supported by this date format. */
&nbsp;    public static final int MAXIMUM_YEAR_SUPPORTED = 9999;
&nbsp;
&nbsp;    /** Useful constant for Monday. Equivalent to java.util.Calendar.MONDAY. */
&nbsp;    public static final int MONDAY = Calendar.MONDAY;
&nbsp;
&nbsp;    /** 
&nbsp;     * Useful constant for Tuesday. Equivalent to java.util.Calendar.TUESDAY. 
&nbsp;     */
&nbsp;    public static final int TUESDAY = Calendar.TUESDAY;
&nbsp;
&nbsp;    /** 
&nbsp;     * Useful constant for Wednesday. Equivalent to 
&nbsp;     * java.util.Calendar.WEDNESDAY. 
&nbsp;     */
&nbsp;    public static final int WEDNESDAY = Calendar.WEDNESDAY;
&nbsp;
&nbsp;    /** 
&nbsp;     * Useful constant for Thrusday. Equivalent to java.util.Calendar.THURSDAY. 
&nbsp;     */
&nbsp;    public static final int THURSDAY = Calendar.THURSDAY;
&nbsp;
&nbsp;    /** Useful constant for Friday. Equivalent to java.util.Calendar.FRIDAY. */
&nbsp;    public static final int FRIDAY = Calendar.FRIDAY;
&nbsp;
&nbsp;    /** 
&nbsp;     * Useful constant for Saturday. Equivalent to java.util.Calendar.SATURDAY.
&nbsp;     */
&nbsp;    public static final int SATURDAY = Calendar.SATURDAY;
&nbsp;
&nbsp;    /** Useful constant for Sunday. Equivalent to java.util.Calendar.SUNDAY. */
&nbsp;    public static final int SUNDAY = Calendar.SUNDAY;
&nbsp;
&nbsp;    /** The number of days in each month in non leap years. */
<b class="fc">&nbsp;    static final int[] LAST_DAY_OF_MONTH =</b>
&nbsp;        {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
&nbsp;
&nbsp;    /** The number of days in a (non-leap) year up to the end of each month. */
<b class="fc">&nbsp;    static final int[] AGGREGATE_DAYS_TO_END_OF_MONTH =</b>
&nbsp;        {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
&nbsp;
&nbsp;    /** The number of days in a year up to the end of the preceding month. */
<b class="fc">&nbsp;    static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =</b>
&nbsp;        {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
&nbsp;
&nbsp;    /** The number of days in a leap year up to the end of each month. */
<b class="fc">&nbsp;    static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH =</b>
&nbsp;        {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
&nbsp;
&nbsp;    /** 
&nbsp;     * The number of days in a leap year up to the end of the preceding month. 
&nbsp;     */
&nbsp;    static final int[] 
<b class="fc">&nbsp;        LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =</b>
&nbsp;            {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
&nbsp;
&nbsp;    /** A useful constant for referring to the first week in a month. */
&nbsp;    public static final int FIRST_WEEK_IN_MONTH = 1;
&nbsp;
&nbsp;    /** A useful constant for referring to the second week in a month. */
&nbsp;    public static final int SECOND_WEEK_IN_MONTH = 2;
&nbsp;
&nbsp;    /** A useful constant for referring to the third week in a month. */
&nbsp;    public static final int THIRD_WEEK_IN_MONTH = 3;
&nbsp;
&nbsp;    /** A useful constant for referring to the fourth week in a month. */
&nbsp;    public static final int FOURTH_WEEK_IN_MONTH = 4;
&nbsp;
&nbsp;    /** A useful constant for referring to the last week in a month. */
&nbsp;    public static final int LAST_WEEK_IN_MONTH = 0;
&nbsp;
&nbsp;    /** Useful range constant. */
&nbsp;    public static final int INCLUDE_NONE = 0;
&nbsp;
&nbsp;    /** Useful range constant. */
&nbsp;    public static final int INCLUDE_FIRST = 1;
&nbsp;
&nbsp;    /** Useful range constant. */
&nbsp;    public static final int INCLUDE_SECOND = 2;
&nbsp;
&nbsp;    /** Useful range constant. */
&nbsp;    public static final int INCLUDE_BOTH = 3;
&nbsp;
&nbsp;    /** 
&nbsp;     * Useful constant for specifying a day of the week relative to a fixed 
&nbsp;     * date. 
&nbsp;     */
&nbsp;    public static final int PRECEDING = -1;
&nbsp;
&nbsp;    /** 
&nbsp;     * Useful constant for specifying a day of the week relative to a fixed 
&nbsp;     * date. 
&nbsp;     */
&nbsp;    public static final int NEAREST = 0;
&nbsp;
&nbsp;    /** 
&nbsp;     * Useful constant for specifying a day of the week relative to a fixed 
&nbsp;     * date. 
&nbsp;     */
&nbsp;    public static final int FOLLOWING = 1;
&nbsp;
&nbsp;    /** A description for the date. */
&nbsp;    private String description;
&nbsp;
&nbsp;    /**
&nbsp;     * Default constructor.
&nbsp;     */
<b class="fc">&nbsp;    protected SerialDate() {</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if the supplied integer code represents a 
&nbsp;     * valid day-of-the-week, and {@code false} otherwise.
&nbsp;     *
&nbsp;     * @param code  the code being checked for validity.
&nbsp;     *
&nbsp;     * @return {@code true} if the supplied integer code represents a 
&nbsp;     *         valid day-of-the-week, and {@code false} otherwise.
&nbsp;     */
&nbsp;    public static boolean isValidWeekdayCode(int code) {
&nbsp;
<b class="nc">&nbsp;        switch(code) {</b>
&nbsp;            case SUNDAY: 
&nbsp;            case MONDAY: 
&nbsp;            case TUESDAY: 
&nbsp;            case WEDNESDAY: 
&nbsp;            case THURSDAY: 
&nbsp;            case FRIDAY: 
&nbsp;            case SATURDAY: 
<b class="nc">&nbsp;                return true;</b>
&nbsp;            default: 
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts the supplied string to a day of the week.
&nbsp;     *
&nbsp;     * @param s  a string representing the day of the week.
&nbsp;     *
&nbsp;     * @return {@code -1} if the string is not convertable, the day of 
&nbsp;     *         the week otherwise.
&nbsp;     */
&nbsp;    public static int stringToWeekdayCode(String s) {
&nbsp;
<b class="nc">&nbsp;        final String[] shortWeekdayNames </b>
<b class="nc">&nbsp;            = DATE_FORMAT_SYMBOLS.getShortWeekdays();</b>
<b class="nc">&nbsp;        final String[] weekDayNames = DATE_FORMAT_SYMBOLS.getWeekdays();</b>
&nbsp;
<b class="nc">&nbsp;        int result = -1;</b>
<b class="nc">&nbsp;        s = s.trim();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; weekDayNames.length; i++) {</b>
<b class="nc">&nbsp;            if (s.equals(shortWeekdayNames[i])) {</b>
<b class="nc">&nbsp;                result = i;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (s.equals(weekDayNames[i])) {</b>
<b class="nc">&nbsp;                result = i;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string representing the supplied day-of-the-week.
&nbsp;     * &lt;P&gt;
&nbsp;     * Need to find a better approach.
&nbsp;     *
&nbsp;     * @param weekday  the day of the week.
&nbsp;     *
&nbsp;     * @return a string representing the supplied day-of-the-week.
&nbsp;     */
&nbsp;    public static String weekdayCodeToString(int weekday) {
<b class="nc">&nbsp;        final String[] weekdays = DATE_FORMAT_SYMBOLS.getWeekdays();</b>
<b class="nc">&nbsp;        return weekdays[weekday];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an array of month names.
&nbsp;     *
&nbsp;     * @return an array of month names.
&nbsp;     */
&nbsp;    public static String[] getMonths() {
&nbsp;
<b class="nc">&nbsp;        return getMonths(false);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an array of month names.
&nbsp;     *
&nbsp;     * @param shortened  a flag indicating that shortened month names should 
&nbsp;     *                   be returned.
&nbsp;     *
&nbsp;     * @return an array of month names.
&nbsp;     */
&nbsp;    public static String[] getMonths(boolean shortened) {
<b class="nc">&nbsp;        if (shortened) {</b>
<b class="nc">&nbsp;            return DATE_FORMAT_SYMBOLS.getShortMonths();</b>
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;            return DATE_FORMAT_SYMBOLS.getMonths();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the supplied integer code represents a valid month.
&nbsp;     *
&nbsp;     * @param code  the code being checked for validity.
&nbsp;     *
&nbsp;     * @return {@code true} if the supplied integer code represents a 
&nbsp;     *         valid month.
&nbsp;     */
&nbsp;    public static boolean isValidMonthCode(int code) {
&nbsp;
<b class="nc">&nbsp;        switch(code) {</b>
&nbsp;            case JANUARY: 
&nbsp;            case FEBRUARY: 
&nbsp;            case MARCH: 
&nbsp;            case APRIL: 
&nbsp;            case MAY: 
&nbsp;            case JUNE: 
&nbsp;            case JULY: 
&nbsp;            case AUGUST: 
&nbsp;            case SEPTEMBER: 
&nbsp;            case OCTOBER: 
&nbsp;            case NOVEMBER: 
&nbsp;            case DECEMBER: 
<b class="nc">&nbsp;                return true;</b>
&nbsp;            default: 
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the quarter for the specified month.
&nbsp;     *
&nbsp;     * @param code  the month code (1-12).
&nbsp;     *
&nbsp;     * @return the quarter that the month belongs to.
&nbsp;     */
&nbsp;    public static int monthCodeToQuarter(int code) {
&nbsp;
<b class="fc">&nbsp;        switch(code) {</b>
&nbsp;            case JANUARY: 
&nbsp;            case FEBRUARY: 
<b class="fc">&nbsp;            case MARCH: return 1;</b>
&nbsp;            case APRIL: 
&nbsp;            case MAY: 
<b class="fc">&nbsp;            case JUNE: return 2;</b>
&nbsp;            case JULY: 
&nbsp;            case AUGUST: 
<b class="nc">&nbsp;            case SEPTEMBER: return 3;</b>
&nbsp;            case OCTOBER: 
&nbsp;            case NOVEMBER: 
<b class="fc">&nbsp;            case DECEMBER: return 4;</b>
<b class="nc">&nbsp;            default: throw new IllegalArgumentException(</b>
&nbsp;                &quot;SerialDate.monthCodeToQuarter: invalid month code.&quot;);
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string representing the supplied month.
&nbsp;     * &lt;P&gt;
&nbsp;     * The string returned is the long form of the month name taken from the 
&nbsp;     * default locale.
&nbsp;     *
&nbsp;     * @param month  the month.
&nbsp;     *
&nbsp;     * @return a string representing the supplied month.
&nbsp;     */
&nbsp;    public static String monthCodeToString(int month) {
<b class="nc">&nbsp;        return monthCodeToString(month, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string representing the supplied month.
&nbsp;     * &lt;P&gt;
&nbsp;     * The string returned is the long or short form of the month name taken 
&nbsp;     * from the default locale.
&nbsp;     *
&nbsp;     * @param month  the month.
&nbsp;     * @param shortened  if {@code true} return the abbreviation of the month.
&nbsp;     *
&nbsp;     * @return a string representing the supplied month.
&nbsp;     */
&nbsp;    public static String monthCodeToString(int month, boolean shortened) {
&nbsp;
&nbsp;        // check arguments...
<b class="nc">&nbsp;        if (!isValidMonthCode(month)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                &quot;SerialDate.monthCodeToString: month outside valid range.&quot;);
&nbsp;        }
&nbsp;
&nbsp;        final String[] months;
&nbsp;
<b class="nc">&nbsp;        if (shortened) {</b>
<b class="nc">&nbsp;            months = DATE_FORMAT_SYMBOLS.getShortMonths();</b>
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;            months = DATE_FORMAT_SYMBOLS.getMonths();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return months[month - 1];</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a string to a month code.
&nbsp;     * &lt;P&gt;
&nbsp;     * This method will return one of the constants JANUARY, FEBRUARY, ..., 
&nbsp;     * DECEMBER that corresponds to the string.  If the string is not 
&nbsp;     * recognised, this method returns -1.
&nbsp;     *
&nbsp;     * @param s  the string to parse.
&nbsp;     *
&nbsp;     * @return {@code -1} if the string is not parseable, the month of the
&nbsp;     *         year otherwise.
&nbsp;     */
&nbsp;    public static int stringToMonthCode(String s) {
&nbsp;
<b class="fc">&nbsp;        final String[] shortMonthNames = DATE_FORMAT_SYMBOLS.getShortMonths();</b>
<b class="fc">&nbsp;        final String[] monthNames = DATE_FORMAT_SYMBOLS.getMonths();</b>
&nbsp;
<b class="fc">&nbsp;        int result = -1;</b>
<b class="fc">&nbsp;        s = s.trim();</b>
&nbsp;
&nbsp;        // first try parsing the string as an integer (1-12)...
&nbsp;        try {
<b class="fc">&nbsp;            result = Integer.parseInt(s);</b>
&nbsp;        }
<b class="fc">&nbsp;        catch (NumberFormatException e) {</b>
&nbsp;            // suppress
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // now search through the month names...
<b class="fc">&nbsp;        if ((result &lt; 1) || (result &gt; 12)) {</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; monthNames.length; i++) {</b>
<b class="fc">&nbsp;                if (s.equals(shortMonthNames[i])) {</b>
<b class="fc">&nbsp;                    result = i + 1;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (s.equals(monthNames[i])) {</b>
<b class="nc">&nbsp;                    result = i + 1;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return result;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the supplied integer code represents a valid 
&nbsp;     * week-in-the-month, and false otherwise.
&nbsp;     *
&nbsp;     * @param code  the code being checked for validity.
&nbsp;     * @return {@code true} if the supplied integer code represents a 
&nbsp;     *         valid week-in-the-month.
&nbsp;     */
&nbsp;    public static boolean isValidWeekInMonthCode(int code) {
<b class="nc">&nbsp;        switch(code) {</b>
&nbsp;            case FIRST_WEEK_IN_MONTH: 
&nbsp;            case SECOND_WEEK_IN_MONTH: 
&nbsp;            case THIRD_WEEK_IN_MONTH: 
&nbsp;            case FOURTH_WEEK_IN_MONTH: 
<b class="nc">&nbsp;            case LAST_WEEK_IN_MONTH: return true;</b>
<b class="nc">&nbsp;            default: return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether or not the specified year is a leap year.
&nbsp;     *
&nbsp;     * @param yyyy  the year (in the range 1900 to 9999).
&nbsp;     *
&nbsp;     * @return {@code true} if the specified year is a leap year.
&nbsp;     */
&nbsp;    public static boolean isLeapYear(int yyyy) {
&nbsp;
<b class="fc">&nbsp;        if ((yyyy % 4) != 0) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        else if ((yyyy % 400) == 0) {</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        else if ((yyyy % 100) == 0) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        else {
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of leap years from 1900 to the specified year 
&nbsp;     * INCLUSIVE.
&nbsp;     * &lt;P&gt;
&nbsp;     * Note that 1900 is not a leap year.
&nbsp;     *
&nbsp;     * @param yyyy  the year (in the range 1900 to 9999).
&nbsp;     *
&nbsp;     * @return the number of leap years from 1900 to the specified year.
&nbsp;     */
&nbsp;    public static int leapYearCount(int yyyy) {
<b class="fc">&nbsp;        int leap4 = (yyyy - 1896) / 4;</b>
<b class="fc">&nbsp;        int leap100 = (yyyy - 1800) / 100;</b>
<b class="fc">&nbsp;        int leap400 = (yyyy - 1600) / 400;</b>
<b class="fc">&nbsp;        return leap4 - leap100 + leap400;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of the last day of the month, taking into account 
&nbsp;     * leap years.
&nbsp;     *
&nbsp;     * @param month  the month.
&nbsp;     * @param yyyy  the year (in the range 1900 to 9999).
&nbsp;     *
&nbsp;     * @return the number of the last day of the month.
&nbsp;     */
&nbsp;    public static int lastDayOfMonth(int month, int yyyy) {
&nbsp;
<b class="fc">&nbsp;        final int result = LAST_DAY_OF_MONTH[month];</b>
<b class="fc">&nbsp;        if (month != FEBRUARY) {</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
<b class="fc">&nbsp;        else if (isLeapYear(yyyy)) {</b>
<b class="fc">&nbsp;            return result + 1;</b>
&nbsp;        }
&nbsp;        else {
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new date by adding the specified number of days to the base 
&nbsp;     * date.
&nbsp;     *
&nbsp;     * @param days  the number of days to add (can be negative).
&nbsp;     * @param base  the base date.
&nbsp;     *
&nbsp;     * @return a new date.
&nbsp;     */
&nbsp;    public static SerialDate addDays(int days, SerialDate base) {
<b class="nc">&nbsp;        int serialDayNumber = base.toSerial() + days;</b>
<b class="nc">&nbsp;        return SerialDate.createInstance(serialDayNumber);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new date by adding the specified number of months to the base 
&nbsp;     * date.
&nbsp;     * &lt;P&gt;
&nbsp;     * If the base date is close to the end of the month, the day on the result
&nbsp;     * may be adjusted slightly:  31 May + 1 month = 30 June.
&nbsp;     *
&nbsp;     * @param months  the number of months to add (can be negative).
&nbsp;     * @param base  the base date.
&nbsp;     *
&nbsp;     * @return a new date.
&nbsp;     */
&nbsp;    public static SerialDate addMonths(int months, SerialDate base) {
<b class="nc">&nbsp;        int yy = (12 * base.getYYYY() + base.getMonth() + months - 1) / 12;</b>
<b class="nc">&nbsp;        if (yy &lt; MINIMUM_YEAR_SUPPORTED || yy &gt; MAXIMUM_YEAR_SUPPORTED) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Call to addMonths resulted in unsupported year&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        int mm = (12 * base.getYYYY() + base.getMonth() + months - 1) % 12 + 1;</b>
<b class="nc">&nbsp;        int dd = Math.min(base.getDayOfMonth(), </b>
<b class="nc">&nbsp;                SerialDate.lastDayOfMonth(mm, yy));</b>
<b class="nc">&nbsp;        return SerialDate.createInstance(dd, mm, yy);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new date by adding the specified number of years to the base 
&nbsp;     * date.
&nbsp;     *
&nbsp;     * @param years  the number of years to add (can be negative).
&nbsp;     * @param base  the base date.
&nbsp;     *
&nbsp;     * @return A new date.
&nbsp;     */
&nbsp;    public static SerialDate addYears(int years, SerialDate base) {
<b class="nc">&nbsp;        int baseY = base.getYYYY();</b>
<b class="nc">&nbsp;        int baseM = base.getMonth();</b>
<b class="nc">&nbsp;        int baseD = base.getDayOfMonth();</b>
&nbsp;
<b class="nc">&nbsp;        int targetY = baseY + years;</b>
<b class="nc">&nbsp;        if (targetY &lt; MINIMUM_YEAR_SUPPORTED || targetY &gt; MAXIMUM_YEAR_SUPPORTED) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Call to addYears resulted in unsupported year&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        int targetD = Math.min(baseD, SerialDate.lastDayOfMonth(baseM, targetY));</b>
<b class="nc">&nbsp;        return SerialDate.createInstance(targetD, baseM, targetY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the latest date that falls on the specified day-of-the-week and 
&nbsp;     * is BEFORE the base date.
&nbsp;     *
&nbsp;     * @param targetWeekday  a code for the target day-of-the-week.
&nbsp;     * @param base  the base date.
&nbsp;     *
&nbsp;     * @return the latest date that falls on the specified day-of-the-week and 
&nbsp;     *         is BEFORE the base date.
&nbsp;     */
&nbsp;    public static SerialDate getPreviousDayOfWeek(int targetWeekday, 
&nbsp;            SerialDate base) {
&nbsp;
&nbsp;        // check arguments...
<b class="nc">&nbsp;        if (!SerialDate.isValidWeekdayCode(targetWeekday)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Invalid day-of-the-week code.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // find the date...
&nbsp;        int adjust;
<b class="nc">&nbsp;        int baseDOW = base.getDayOfWeek();</b>
<b class="nc">&nbsp;        if (baseDOW &gt; targetWeekday) {</b>
<b class="nc">&nbsp;            adjust = Math.min(0, targetWeekday - baseDOW);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            adjust = -7 + Math.max(0, targetWeekday - baseDOW);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return SerialDate.addDays(adjust, base);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the earliest date that falls on the specified day-of-the-week
&nbsp;     * and is AFTER the base date.
&nbsp;     *
&nbsp;     * @param targetWeekday  a code for the target day-of-the-week.
&nbsp;     * @param base  the base date.
&nbsp;     *
&nbsp;     * @return the earliest date that falls on the specified day-of-the-week 
&nbsp;     *         and is AFTER the base date.
&nbsp;     */
&nbsp;    public static SerialDate getFollowingDayOfWeek(int targetWeekday, 
&nbsp;            SerialDate base) {
&nbsp;
&nbsp;        // check arguments...
<b class="nc">&nbsp;        if (!SerialDate.isValidWeekdayCode(targetWeekday)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                &quot;Invalid day-of-the-week code.&quot;
&nbsp;            );
&nbsp;        }
&nbsp;
&nbsp;        // find the date...
&nbsp;        int adjust;
<b class="nc">&nbsp;        int baseDOW = base.getDayOfWeek();</b>
<b class="nc">&nbsp;        if (baseDOW &gt; targetWeekday) {</b>
<b class="nc">&nbsp;            adjust = 7 + Math.min(0, targetWeekday - baseDOW);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            adjust = Math.max(0, targetWeekday - baseDOW);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return SerialDate.addDays(adjust, base);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the date that falls on the specified day-of-the-week and is
&nbsp;     * CLOSEST to the base date.
&nbsp;     *
&nbsp;     * @param targetDOW  a code for the target day-of-the-week.
&nbsp;     * @param base  the base date.
&nbsp;     *
&nbsp;     * @return the date that falls on the specified day-of-the-week and is 
&nbsp;     *         CLOSEST to the base date.
&nbsp;     */
&nbsp;    public static SerialDate getNearestDayOfWeek(int targetDOW, SerialDate base) {
&nbsp;
&nbsp;        // check arguments...
<b class="nc">&nbsp;        if (!SerialDate.isValidWeekdayCode(targetDOW)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Invalid day-of-the-week code.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // find the date...
<b class="nc">&nbsp;        final int baseDOW = base.getDayOfWeek();</b>
<b class="nc">&nbsp;        int adjust = -Math.abs(targetDOW - baseDOW);</b>
<b class="nc">&nbsp;        if (adjust &gt;= 4) {</b>
<b class="nc">&nbsp;            adjust = 7 - adjust;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (adjust &lt;= -4) {</b>
<b class="nc">&nbsp;            adjust = 7 + adjust;</b>
&nbsp;        }
<b class="nc">&nbsp;        return SerialDate.addDays(adjust, base);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rolls the date forward to the last day of the month.
&nbsp;     *
&nbsp;     * @param base  the base date.
&nbsp;     *
&nbsp;     * @return a new serial date.
&nbsp;     */
&nbsp;    public SerialDate getEndOfCurrentMonth(SerialDate base) {
<b class="nc">&nbsp;        int last = SerialDate.lastDayOfMonth(base.getMonth(), base.getYYYY());</b>
<b class="nc">&nbsp;        return SerialDate.createInstance(last, base.getMonth(), base.getYYYY());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string corresponding to the week-in-the-month code.
&nbsp;     * &lt;P&gt;
&nbsp;     * Need to find a better approach.
&nbsp;     *
&nbsp;     * @param count  an integer code representing the week-in-the-month.
&nbsp;     *
&nbsp;     * @return a string corresponding to the week-in-the-month code.
&nbsp;     */
&nbsp;    public static String weekInMonthToString(int count) {
&nbsp;
<b class="nc">&nbsp;        switch (count) {</b>
<b class="nc">&nbsp;            case SerialDate.FIRST_WEEK_IN_MONTH : return &quot;First&quot;;</b>
<b class="nc">&nbsp;            case SerialDate.SECOND_WEEK_IN_MONTH : return &quot;Second&quot;;</b>
<b class="nc">&nbsp;            case SerialDate.THIRD_WEEK_IN_MONTH : return &quot;Third&quot;;</b>
<b class="nc">&nbsp;            case SerialDate.FOURTH_WEEK_IN_MONTH : return &quot;Fourth&quot;;</b>
<b class="nc">&nbsp;            case SerialDate.LAST_WEEK_IN_MONTH : return &quot;Last&quot;;</b>
&nbsp;            default :
<b class="nc">&nbsp;                return &quot;SerialDate.weekInMonthToString(): invalid code.&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string representing the supplied &#39;relative&#39;.
&nbsp;     * &lt;P&gt;
&nbsp;     * Need to find a better approach.
&nbsp;     *
&nbsp;     * @param relative  a constant representing the &#39;relative&#39;.
&nbsp;     *
&nbsp;     * @return a string representing the supplied &#39;relative&#39;.
&nbsp;     */
&nbsp;    public static String relativeToString(int relative) {
&nbsp;
<b class="nc">&nbsp;        switch (relative) {</b>
<b class="nc">&nbsp;            case SerialDate.PRECEDING : return &quot;Preceding&quot;;</b>
<b class="nc">&nbsp;            case SerialDate.NEAREST : return &quot;Nearest&quot;;</b>
<b class="nc">&nbsp;            case SerialDate.FOLLOWING : return &quot;Following&quot;;</b>
<b class="nc">&nbsp;            default : return &quot;ERROR : Relative To String&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method that returns an instance of some concrete subclass of 
&nbsp;     * {@link SerialDate}.
&nbsp;     *
&nbsp;     * @param day  the day (1-31).
&nbsp;     * @param month  the month (1-12).
&nbsp;     * @param yyyy  the year (in the range 1900 to 9999).
&nbsp;     *
&nbsp;     * @return An instance of {@link SerialDate}.
&nbsp;     */
&nbsp;    public static SerialDate createInstance(int day, int month, int yyyy) {
<b class="fc">&nbsp;        return new SpreadsheetDate(day, month, yyyy);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method that returns an instance of some concrete subclass of 
&nbsp;     * {@link SerialDate}.
&nbsp;     *
&nbsp;     * @param serial  the serial number for the day (1 January 1900 = 2).
&nbsp;     *
&nbsp;     * @return a instance of SerialDate.
&nbsp;     */
&nbsp;    public static SerialDate createInstance(int serial) {
<b class="fc">&nbsp;        return new SpreadsheetDate(serial);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Factory method that returns an instance of a subclass of SerialDate.
&nbsp;     *
&nbsp;     * @param date  A Java date object.
&nbsp;     *
&nbsp;     * @return a instance of SerialDate.
&nbsp;     */
&nbsp;    public static SerialDate createInstance(java.util.Date date) {
&nbsp;
<b class="nc">&nbsp;        GregorianCalendar calendar = new GregorianCalendar();</b>
<b class="nc">&nbsp;        calendar.setTime(date);</b>
<b class="nc">&nbsp;        return new SpreadsheetDate(calendar.get(Calendar.DATE), </b>
<b class="nc">&nbsp;                calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.YEAR));</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the serial number for the date, where 1 January 1900 = 2 (this
&nbsp;     * corresponds, almost, to the numbering system used in Microsoft Excel for
&nbsp;     * Windows and Lotus 1-2-3).
&nbsp;     *
&nbsp;     * @return the serial number for the date.
&nbsp;     */
&nbsp;    public abstract int toSerial();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a java.util.Date.  Since java.util.Date has more precision than
&nbsp;     * SerialDate, we need to define a convention for the &#39;time of day&#39;.
&nbsp;     *
&nbsp;     * @return this as {@code java.util.Date}.
&nbsp;     */
&nbsp;    public abstract java.util.Date toDate();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the description that is attached to the date.  It is not 
&nbsp;     * required that a date have a description, but for some applications it 
&nbsp;     * is useful.
&nbsp;     *
&nbsp;     * @return The description (possibly {@code null}).
&nbsp;     */
&nbsp;    public String getDescription() {
<b class="nc">&nbsp;        return this.description;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the description for the date.
&nbsp;     *
&nbsp;     * @param description  the description for this date ({@code null}
&nbsp;     *                     permitted).
&nbsp;     */
&nbsp;    public void setDescription(String description) {
<b class="nc">&nbsp;        this.description = description;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts the date to a string.
&nbsp;     *
&nbsp;     * @return  a string representation of the date.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        return getDayOfMonth() + &quot;-&quot; + SerialDate.monthCodeToString(getMonth())</b>
<b class="nc">&nbsp;                               + &quot;-&quot; + getYYYY();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the year (assume a valid range of 1900 to 9999).
&nbsp;     *
&nbsp;     * @return the year.
&nbsp;     */
&nbsp;    public abstract int getYYYY();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the month (January = 1, February = 2, March = 3).
&nbsp;     *
&nbsp;     * @return the month of the year.
&nbsp;     */
&nbsp;    public abstract int getMonth();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the day of the month.
&nbsp;     *
&nbsp;     * @return the day of the month.
&nbsp;     */
&nbsp;    public abstract int getDayOfMonth();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the day of the week.
&nbsp;     *
&nbsp;     * @return the day of the week.
&nbsp;     */
&nbsp;    public abstract int getDayOfWeek();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the difference (in days) between this date and the specified 
&nbsp;     * &#39;other&#39; date.
&nbsp;     * &lt;P&gt;
&nbsp;     * The result is positive if this date is after the &#39;other&#39; date and
&nbsp;     * negative if it is before the &#39;other&#39; date.
&nbsp;     *
&nbsp;     * @param other  the date being compared to.
&nbsp;     *
&nbsp;     * @return the difference between this and the other date.
&nbsp;     */
&nbsp;    public abstract int compare(SerialDate other);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this SerialDate represents the same date as the 
&nbsp;     * specified SerialDate.
&nbsp;     *
&nbsp;     * @param other  the date being compared to.
&nbsp;     *
&nbsp;     * @return {@code true} if this SerialDate represents the same date as 
&nbsp;     *         the specified SerialDate.
&nbsp;     */
&nbsp;    public abstract boolean isOn(SerialDate other);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this SerialDate represents an earlier date compared to
&nbsp;     * the specified SerialDate.
&nbsp;     *
&nbsp;     * @param other  The date being compared to.
&nbsp;     *
&nbsp;     * @return {@code true} if this SerialDate represents an earlier date 
&nbsp;     *         compared to the specified SerialDate.
&nbsp;     */
&nbsp;    public abstract boolean isBefore(SerialDate other);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this SerialDate represents the same date as the 
&nbsp;     * specified SerialDate.
&nbsp;     *
&nbsp;     * @param other  the date being compared to.
&nbsp;     *
&nbsp;     * @return {@code true} if this SerialDate represents the same date
&nbsp;     *         as the specified SerialDate.
&nbsp;     */
&nbsp;    public abstract boolean isOnOrBefore(SerialDate other);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this SerialDate represents the same date as the 
&nbsp;     * specified SerialDate.
&nbsp;     *
&nbsp;     * @param other  the date being compared to.
&nbsp;     *
&nbsp;     * @return {@code true} if this SerialDate represents the same date
&nbsp;     *         as the specified SerialDate.
&nbsp;     */
&nbsp;    public abstract boolean isAfter(SerialDate other);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this SerialDate represents the same date as the 
&nbsp;     * specified SerialDate.
&nbsp;     *
&nbsp;     * @param other  the date being compared to.
&nbsp;     *
&nbsp;     * @return {@code true} if this SerialDate represents the same date
&nbsp;     *         as the specified SerialDate.
&nbsp;     */
&nbsp;    public abstract boolean isOnOrAfter(SerialDate other);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this {@link SerialDate} is within the 
&nbsp;     * specified range (INCLUSIVE).  The date order of d1 and d2 is not 
&nbsp;     * important.
&nbsp;     *
&nbsp;     * @param d1  a boundary date for the range.
&nbsp;     * @param d2  the other boundary date for the range.
&nbsp;     *
&nbsp;     * @return A boolean.
&nbsp;     */
&nbsp;    public abstract boolean isInRange(SerialDate d1, SerialDate d2);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this {@link SerialDate} is within the 
&nbsp;     * specified range (caller specifies whether or not the end-points are 
&nbsp;     * included).  The date order of d1 and d2 is not important.
&nbsp;     *
&nbsp;     * @param d1  a boundary date for the range.
&nbsp;     * @param d2  the other boundary date for the range.
&nbsp;     * @param include  a code that controls whether or not the start and end 
&nbsp;     *                 dates are included in the range.
&nbsp;     *
&nbsp;     * @return A boolean.
&nbsp;     */
&nbsp;    public abstract boolean isInRange(SerialDate d1, SerialDate d2, 
&nbsp;                                      int include);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the latest date that falls on the specified day-of-the-week and
&nbsp;     * is BEFORE this date.
&nbsp;     *
&nbsp;     * @param targetDOW  a code for the target day-of-the-week.
&nbsp;     *
&nbsp;     * @return the latest date that falls on the specified day-of-the-week and
&nbsp;     *         is BEFORE this date.
&nbsp;     */
&nbsp;    public SerialDate getPreviousDayOfWeek(int targetDOW) {
<b class="nc">&nbsp;        return getPreviousDayOfWeek(targetDOW, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the earliest date that falls on the specified day-of-the-week
&nbsp;     * and is AFTER this date.
&nbsp;     *
&nbsp;     * @param targetDOW  a code for the target day-of-the-week.
&nbsp;     *
&nbsp;     * @return the earliest date that falls on the specified day-of-the-week
&nbsp;     *         and is AFTER this date.
&nbsp;     */
&nbsp;    public SerialDate getFollowingDayOfWeek(int targetDOW) {
<b class="nc">&nbsp;        return getFollowingDayOfWeek(targetDOW, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the nearest date that falls on the specified day-of-the-week.
&nbsp;     *
&nbsp;     * @param targetDOW  a code for the target day-of-the-week.
&nbsp;     *
&nbsp;     * @return the nearest date that falls on the specified day-of-the-week.
&nbsp;     */
&nbsp;    public SerialDate getNearestDayOfWeek(int targetDOW) {
<b class="nc">&nbsp;        return getNearestDayOfWeek(targetDOW, this);</b>
&nbsp;    }
&nbsp;
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-10-20 10:56</div>
</div>
</body>
</html>
