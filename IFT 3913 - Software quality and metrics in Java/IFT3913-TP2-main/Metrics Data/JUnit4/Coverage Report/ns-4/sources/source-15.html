


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > LogAxis</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jfree.chart.axis</a>
</div>

<h1>Coverage Summary for Class: LogAxis (org.jfree.chart.axis)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LogAxis</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55%
  </span>
  <span class="absValue">
    (22/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48,6%
  </span>
  <span class="absValue">
    (168/346)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* ===========================================================
&nbsp; * JFreeChart : a free chart library for the Java(tm) platform
&nbsp; * ===========================================================
&nbsp; *
&nbsp; * (C) Copyright 2000-2022, by David Gilbert and Contributors.
&nbsp; *
&nbsp; * Project Info:  http://www.jfree.org/jfreechart/index.html
&nbsp; *
&nbsp; * This library is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU Lesser General Public License as published by
&nbsp; * the Free Software Foundation; either version 2.1 of the License, or
&nbsp; * (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful, but
&nbsp; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
&nbsp; * License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
&nbsp; * USA.
&nbsp; *
&nbsp; * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. 
&nbsp; * Other names may be trademarks of their respective owners.]
&nbsp; *
&nbsp; * ------------
&nbsp; * LogAxis.java
&nbsp; * ------------
&nbsp; * (C) Copyright 2006-2022, by David Gilbert and Contributors.
&nbsp; *
&nbsp; * Original Author:  David Gilbert;
&nbsp; * Contributor(s):   Andrew Mickish (patch 1868745);
&nbsp; *                   Peter Kolb (patches 1934255 and 2603321);
&nbsp; */
&nbsp;
&nbsp;package org.jfree.chart.axis;
&nbsp;
&nbsp;import java.awt.Font;
&nbsp;import java.awt.Graphics2D;
&nbsp;import java.awt.font.FontRenderContext;
&nbsp;import java.awt.font.LineMetrics;
&nbsp;import java.awt.font.TextAttribute;
&nbsp;import java.awt.geom.Rectangle2D;
&nbsp;import java.text.AttributedString;
&nbsp;import java.text.DecimalFormat;
&nbsp;import java.text.Format;
&nbsp;import java.text.NumberFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;import org.jfree.chart.event.AxisChangeEvent;
&nbsp;import org.jfree.chart.plot.Plot;
&nbsp;import org.jfree.chart.plot.PlotRenderingInfo;
&nbsp;import org.jfree.chart.plot.ValueAxisPlot;
&nbsp;import org.jfree.chart.api.RectangleEdge;
&nbsp;import org.jfree.chart.api.RectangleInsets;
&nbsp;import org.jfree.chart.text.TextAnchor;
&nbsp;import org.jfree.chart.util.AttrStringUtils;
&nbsp;import org.jfree.chart.internal.Args;
&nbsp;import org.jfree.data.Range;
&nbsp;
&nbsp;/**
&nbsp; * A numerical axis that uses a logarithmic scale.  The class is an
&nbsp; * alternative to the {@link LogarithmicAxis} class.
&nbsp; */
&nbsp;public class LogAxis extends ValueAxis {
&nbsp;
&nbsp;    /** The logarithm base. */
<b class="fc">&nbsp;    private double base = 10.0;</b>
&nbsp;
&nbsp;    /** The logarithm of the base value - cached for performance. */
<b class="fc">&nbsp;    private double baseLog = Math.log(10.0);</b>
&nbsp;
&nbsp;    /** 
&nbsp;     * The base symbol to display (if {@code null} then the numerical
&nbsp;     * value of the base is displayed).
&nbsp;     */
<b class="fc">&nbsp;    private String baseSymbol = null;</b>
&nbsp;    
&nbsp;    /** 
&nbsp;     * The formatter to use for the base value when the base is displayed
&nbsp;     * as a numerical value.
&nbsp;     */
<b class="fc">&nbsp;    private Format baseFormatter = new DecimalFormat(&quot;0&quot;);</b>
&nbsp;    
&nbsp;    /**  The smallest value permitted on the axis. */
<b class="fc">&nbsp;    private double smallestValue = 1E-100;</b>
&nbsp;
&nbsp;    /** The current tick unit. */
&nbsp;    private NumberTickUnit tickUnit;
&nbsp;
&nbsp;    /** The override number format. */
&nbsp;    private NumberFormat numberFormatOverride;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@code LogAxis} with no label.
&nbsp;     */
&nbsp;    public LogAxis() {
<b class="fc">&nbsp;        this(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@code LogAxis} with the given label.
&nbsp;     *
&nbsp;     * @param label  the axis label ({@code null} permitted).
&nbsp;     */
&nbsp;    public LogAxis(String label) {
<b class="fc">&nbsp;        super(label, new NumberTickUnitSource());</b>
<b class="fc">&nbsp;        setDefaultAutoRange(new Range(0.01, 1.0));</b>
<b class="fc">&nbsp;        this.tickUnit = new NumberTickUnit(1.0, new DecimalFormat(&quot;0.#&quot;), 10);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the base for the logarithm calculation.  The default value is
&nbsp;     * {@code 10.0}.
&nbsp;     *
&nbsp;     * @return The base for the logarithm calculation.
&nbsp;     *
&nbsp;     * @see #setBase(double)
&nbsp;     */
&nbsp;    public double getBase() {
<b class="nc">&nbsp;        return this.base;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the base for the logarithm calculation and sends a change event to
&nbsp;     * all registered listeners.
&nbsp;     *
&nbsp;     * @param base  the base value (must be &amp;gt; 1.0).
&nbsp;     *
&nbsp;     * @see #getBase()
&nbsp;     */
&nbsp;    public void setBase(double base) {
<b class="fc">&nbsp;        if (base &lt;= 1.0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Requires &#39;base&#39; &gt; 1.0.&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.base = base;</b>
<b class="fc">&nbsp;        this.baseLog = Math.log(base);</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the symbol used to represent the base of the logarithmic scale
&nbsp;     * for the axis.  If this is {@code null} (the default) then the 
&nbsp;     * numerical value of the base is displayed.
&nbsp;     * 
&nbsp;     * @return The base symbol (possibly {@code null}).
&nbsp;     */
&nbsp;    public String getBaseSymbol() {
<b class="nc">&nbsp;        return this.baseSymbol;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets the symbol used to represent the base value of the logarithmic 
&nbsp;     * scale and sends a change event to all registered listeners.
&nbsp;     * 
&nbsp;     * @param symbol  the symbol ({@code null} permitted).
&nbsp;     */
&nbsp;    public void setBaseSymbol(String symbol) {
<b class="nc">&nbsp;        this.baseSymbol = symbol;</b>
<b class="nc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns the formatter used to format the base value of the logarithmic
&nbsp;     * scale when it is displayed numerically.  The default value is
&nbsp;     * {@code new DecimalFormat(&quot;0&quot;)}.
&nbsp;     * 
&nbsp;     * @return The base formatter (never {@code null}).
&nbsp;     */
&nbsp;    public Format getBaseFormatter() {
<b class="nc">&nbsp;        return this.baseFormatter;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Sets the formatter used to format the base value of the logarithmic 
&nbsp;     * scale when it is displayed numerically and sends a change event to all
&nbsp;     * registered listeners.
&nbsp;     * 
&nbsp;     * @param formatter  the formatter ({@code null} not permitted).
&nbsp;     */
&nbsp;    public void setBaseFormatter(Format formatter) {
<b class="nc">&nbsp;        Args.nullNotPermitted(formatter, &quot;formatter&quot;);</b>
<b class="nc">&nbsp;        this.baseFormatter = formatter;</b>
<b class="nc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns the smallest value represented by the axis.
&nbsp;     *
&nbsp;     * @return The smallest value represented by the axis.
&nbsp;     *
&nbsp;     * @see #setSmallestValue(double)
&nbsp;     */
&nbsp;    public double getSmallestValue() {
<b class="nc">&nbsp;        return this.smallestValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the smallest value represented by the axis and sends a change event
&nbsp;     * to all registered listeners.
&nbsp;     *
&nbsp;     * @param value  the value.
&nbsp;     *
&nbsp;     * @see #getSmallestValue()
&nbsp;     */
&nbsp;    public void setSmallestValue(double value) {
<b class="fc">&nbsp;        if (value &lt;= 0.0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Requires &#39;value&#39; &gt; 0.0.&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.smallestValue = value;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current tick unit.
&nbsp;     *
&nbsp;     * @return The current tick unit.
&nbsp;     *
&nbsp;     * @see #setTickUnit(NumberTickUnit)
&nbsp;     */
&nbsp;    public NumberTickUnit getTickUnit() {
<b class="fc">&nbsp;        return this.tickUnit;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tick unit for the axis and sends an {@link AxisChangeEvent} to
&nbsp;     * all registered listeners.  A side effect of calling this method is that
&nbsp;     * the &quot;auto-select&quot; feature for tick units is switched off (you can
&nbsp;     * restore it using the {@link ValueAxis#setAutoTickUnitSelection(boolean)}
&nbsp;     * method).
&nbsp;     *
&nbsp;     * @param unit  the new tick unit ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getTickUnit()
&nbsp;     */
&nbsp;    public void setTickUnit(NumberTickUnit unit) {
&nbsp;        // defer argument checking...
<b class="nc">&nbsp;        setTickUnit(unit, true, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tick unit for the axis and, if requested, sends an
&nbsp;     * {@link AxisChangeEvent} to all registered listeners.  In addition, an
&nbsp;     * option is provided to turn off the &quot;auto-select&quot; feature for tick units
&nbsp;     * (you can restore it using the
&nbsp;     * {@link ValueAxis#setAutoTickUnitSelection(boolean)} method).
&nbsp;     *
&nbsp;     * @param unit  the new tick unit ({@code null} not permitted).
&nbsp;     * @param notify  notify listeners?
&nbsp;     * @param turnOffAutoSelect  turn off the auto-tick selection?
&nbsp;     *
&nbsp;     * @see #getTickUnit()
&nbsp;     */
&nbsp;    public void setTickUnit(NumberTickUnit unit, boolean notify,
&nbsp;            boolean turnOffAutoSelect) {
<b class="fc">&nbsp;        Args.nullNotPermitted(unit, &quot;unit&quot;);</b>
<b class="fc">&nbsp;        this.tickUnit = unit;</b>
<b class="fc">&nbsp;        if (turnOffAutoSelect) {</b>
<b class="nc">&nbsp;            setAutoTickUnitSelection(false, false);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (notify) {</b>
<b class="nc">&nbsp;            fireChangeEvent();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number format override.  If this is non-{@code null}, 
&nbsp;     * then it will be used to format the numbers on the axis.
&nbsp;     *
&nbsp;     * @return The number formatter (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #setNumberFormatOverride(NumberFormat)
&nbsp;     */
&nbsp;    public NumberFormat getNumberFormatOverride() {
<b class="nc">&nbsp;        return this.numberFormatOverride;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the number format override and sends a change event to all 
&nbsp;     * registered listeners.  If this is non-{@code null}, then it will be
&nbsp;     * used to format the numbers on the axis.
&nbsp;     *
&nbsp;     * @param formatter  the number formatter ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getNumberFormatOverride()
&nbsp;     */
&nbsp;    public void setNumberFormatOverride(NumberFormat formatter) {
<b class="nc">&nbsp;        this.numberFormatOverride = formatter;</b>
<b class="nc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the log of the given value, using the current base.
&nbsp;     *
&nbsp;     * @param value  the value.
&nbsp;     *
&nbsp;     * @return The log of the given value.
&nbsp;     *
&nbsp;     * @see #calculateValue(double)
&nbsp;     * @see #getBase()
&nbsp;     */
&nbsp;    public double calculateLog(double value) {
<b class="fc">&nbsp;        return Math.log(value) / this.baseLog;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the value from a given log.
&nbsp;     *
&nbsp;     * @param log  the log value.
&nbsp;     *
&nbsp;     * @return The value with the given log.
&nbsp;     *
&nbsp;     * @see #calculateLog(double)
&nbsp;     * @see #getBase()
&nbsp;     */
&nbsp;    public double calculateValue(double log) {
<b class="fc">&nbsp;        return Math.pow(this.base, log);</b>
&nbsp;    }
&nbsp;    
&nbsp;    private double calculateValueNoINF(double log) {
<b class="fc">&nbsp;        double result = calculateValue(log);</b>
<b class="fc">&nbsp;        if (Double.isInfinite(result)) {</b>
<b class="nc">&nbsp;            result = Double.MAX_VALUE;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (result &lt;= 0.0) {</b>
<b class="nc">&nbsp;            result = Double.MIN_VALUE;</b>
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a Java2D coordinate to an axis value, assuming that the
&nbsp;     * axis is aligned to the specified {@code edge} of the {@code area}.
&nbsp;     *
&nbsp;     * @param java2DValue  the Java2D coordinate.
&nbsp;     * @param area  the area for plotting data ({@code null} not 
&nbsp;     *     permitted).
&nbsp;     * @param edge  the edge that the axis is aligned to ({@code null} not
&nbsp;     *     permitted).
&nbsp;     *
&nbsp;     * @return A value along the axis scale.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double java2DToValue(double java2DValue, Rectangle2D area,
&nbsp;            RectangleEdge edge) {
&nbsp;
<b class="fc">&nbsp;        Range range = getRange();</b>
<b class="fc">&nbsp;        double axisMin = calculateLog(Math.max(this.smallestValue, </b>
<b class="fc">&nbsp;                range.getLowerBound()));</b>
<b class="fc">&nbsp;        double axisMax = calculateLog(range.getUpperBound());</b>
&nbsp;
<b class="fc">&nbsp;        double min = 0.0;</b>
<b class="fc">&nbsp;        double max = 0.0;</b>
<b class="fc">&nbsp;        if (RectangleEdge.isTopOrBottom(edge)) {</b>
<b class="fc">&nbsp;            min = area.getX();</b>
<b class="fc">&nbsp;            max = area.getMaxX();</b>
<b class="fc">&nbsp;        } else if (RectangleEdge.isLeftOrRight(edge)) {</b>
<b class="fc">&nbsp;            min = area.getMaxY();</b>
<b class="fc">&nbsp;            max = area.getY();</b>
&nbsp;        }
&nbsp;        double log;
<b class="fc">&nbsp;        if (isInverted()) {</b>
<b class="fc">&nbsp;            log = axisMax - (java2DValue - min) / (max - min)</b>
&nbsp;                    * (axisMax - axisMin);
&nbsp;        } else {
<b class="fc">&nbsp;            log = axisMin + (java2DValue - min) / (max - min)</b>
&nbsp;                    * (axisMax - axisMin);
&nbsp;        }
<b class="fc">&nbsp;        return calculateValue(log);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a value on the axis scale to a Java2D coordinate relative to
&nbsp;     * the given {@code area}, based on the axis running along the
&nbsp;     * specified {@code edge}.
&nbsp;     *
&nbsp;     * @param value  the data value.
&nbsp;     * @param area  the area ({@code null} not permitted).
&nbsp;     * @param edge  the edge ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @return The Java2D coordinate corresponding to {@code value}.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public double valueToJava2D(double value, Rectangle2D area,
&nbsp;            RectangleEdge edge) {
&nbsp;
<b class="fc">&nbsp;        Range range = getRange();</b>
<b class="fc">&nbsp;        double axisMin = calculateLog(range.getLowerBound());</b>
<b class="fc">&nbsp;        double axisMax = calculateLog(range.getUpperBound());</b>
<b class="fc">&nbsp;        value = calculateLog(value);</b>
&nbsp;
<b class="fc">&nbsp;        double min = 0.0;</b>
<b class="fc">&nbsp;        double max = 0.0;</b>
<b class="fc">&nbsp;        if (RectangleEdge.isTopOrBottom(edge)) {</b>
<b class="fc">&nbsp;            min = area.getX();</b>
<b class="fc">&nbsp;            max = area.getMaxX();</b>
<b class="nc">&nbsp;        } else if (RectangleEdge.isLeftOrRight(edge)) {</b>
<b class="nc">&nbsp;            max = area.getMinY();</b>
<b class="nc">&nbsp;            min = area.getMaxY();</b>
&nbsp;        }
<b class="fc">&nbsp;        if (isInverted()) {</b>
<b class="nc">&nbsp;            return max</b>
&nbsp;                   - ((value - axisMin) / (axisMax - axisMin)) * (max - min);
&nbsp;        } else {
<b class="fc">&nbsp;            return min</b>
&nbsp;                   + ((value - axisMin) / (axisMax - axisMin)) * (max - min);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures the axis.  This method is typically called when an axis
&nbsp;     * is assigned to a new plot.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void configure() {
<b class="fc">&nbsp;        if (isAutoRange()) {</b>
<b class="fc">&nbsp;            autoAdjustRange();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adjusts the axis range to match the data range that the axis is
&nbsp;     * required to display.
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected void autoAdjustRange() {
<b class="fc">&nbsp;        Plot plot = getPlot();</b>
<b class="fc">&nbsp;        if (plot == null) {</b>
&nbsp;            return;  // no plot, no data
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (plot instanceof ValueAxisPlot) {</b>
<b class="fc">&nbsp;            ValueAxisPlot vap = (ValueAxisPlot) plot;</b>
&nbsp;
<b class="fc">&nbsp;            Range r = vap.getDataRange(this);</b>
<b class="fc">&nbsp;            if (r == null) {</b>
<b class="fc">&nbsp;                r = getDefaultAutoRange();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            double upper = r.getUpperBound();</b>
<b class="fc">&nbsp;            double lower = Math.max(r.getLowerBound(), this.smallestValue);</b>
<b class="fc">&nbsp;            double range = upper - lower;</b>
&nbsp;
&nbsp;            // if fixed auto range, then derive lower bound...
<b class="fc">&nbsp;            double fixedAutoRange = getFixedAutoRange();</b>
<b class="fc">&nbsp;            if (fixedAutoRange &gt; 0.0) {</b>
<b class="nc">&nbsp;                lower = Math.max(upper - fixedAutoRange, this.smallestValue);</b>
&nbsp;            }
&nbsp;            else {
&nbsp;                // ensure the autorange is at least &lt;minRange&gt; in size...
<b class="fc">&nbsp;                double minRange = getAutoRangeMinimumSize();</b>
<b class="fc">&nbsp;                if (range &lt; minRange) {</b>
<b class="nc">&nbsp;                    double expand = (minRange - range) / 2;</b>
<b class="nc">&nbsp;                    upper = upper + expand;</b>
<b class="nc">&nbsp;                    lower = lower - expand;</b>
&nbsp;                }
&nbsp;
&nbsp;                // apply the margins - these should apply to the exponent range
<b class="fc">&nbsp;                double logUpper = calculateLog(upper);</b>
<b class="fc">&nbsp;                double logLower = calculateLog(lower);</b>
<b class="fc">&nbsp;                double logRange = logUpper - logLower;</b>
<b class="fc">&nbsp;                logUpper = logUpper + getUpperMargin() * logRange;</b>
<b class="fc">&nbsp;                logLower = logLower - getLowerMargin() * logRange;</b>
<b class="fc">&nbsp;                upper = calculateValueNoINF(logUpper);</b>
<b class="fc">&nbsp;                lower = calculateValueNoINF(logLower);</b>
&nbsp;            }
<b class="fc">&nbsp;            setRange(new Range(lower, upper), false, false);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the axis on a Java 2D graphics device (such as the screen or a
&nbsp;     * printer).
&nbsp;     *
&nbsp;     * @param g2  the graphics device ({@code null} not permitted).
&nbsp;     * @param cursor  the cursor location (determines where to draw the axis).
&nbsp;     * @param plotArea  the area within which the axes and plot should be drawn.
&nbsp;     * @param dataArea  the area within which the data should be drawn.
&nbsp;     * @param edge  the axis location ({@code null} not permitted).
&nbsp;     * @param plotState  collects information about the plot ({@code null} 
&nbsp;     *         permitted).
&nbsp;     *
&nbsp;     * @return The axis state (never {@code null}).
&nbsp;     */
&nbsp;    @Override
&nbsp;    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,
&nbsp;            Rectangle2D dataArea, RectangleEdge edge,
&nbsp;            PlotRenderingInfo plotState) {
&nbsp;
&nbsp;        AxisState state;
&nbsp;        // if the axis is not visible, don&#39;t draw it...
<b class="nc">&nbsp;        if (!isVisible()) {</b>
<b class="nc">&nbsp;            state = new AxisState(cursor);</b>
&nbsp;            // even though the axis is not visible, we need ticks for the
&nbsp;            // gridlines...
<b class="nc">&nbsp;            List ticks = refreshTicks(g2, state, dataArea, edge);</b>
<b class="nc">&nbsp;            state.setTicks(ticks);</b>
<b class="nc">&nbsp;            return state;</b>
&nbsp;        }
<b class="nc">&nbsp;        state = drawTickMarksAndLabels(g2, cursor, plotArea, dataArea, edge);</b>
<b class="nc">&nbsp;        if (getAttributedLabel() != null) {</b>
<b class="nc">&nbsp;            state = drawAttributedLabel(getAttributedLabel(), g2, plotArea, </b>
&nbsp;                    dataArea, edge, state);
&nbsp;            
&nbsp;        } else {
<b class="nc">&nbsp;            state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);</b>
&nbsp;        }
<b class="nc">&nbsp;        createAndAddEntity(cursor, state, dataArea, edge, plotState);</b>
<b class="nc">&nbsp;        return state;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the positions of the tick labels for the axis, storing the
&nbsp;     * results in the tick label list (ready for drawing).
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param state  the axis state.
&nbsp;     * @param dataArea  the area in which the plot should be drawn.
&nbsp;     * @param edge  the location of the axis.
&nbsp;     *
&nbsp;     * @return A list of ticks.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public List refreshTicks(Graphics2D g2, AxisState state,
&nbsp;            Rectangle2D dataArea, RectangleEdge edge) {
<b class="fc">&nbsp;        List result = new java.util.ArrayList();</b>
<b class="fc">&nbsp;        if (RectangleEdge.isTopOrBottom(edge)) {</b>
<b class="fc">&nbsp;            result = refreshTicksHorizontal(g2, dataArea, edge);</b>
&nbsp;        }
<b class="nc">&nbsp;        else if (RectangleEdge.isLeftOrRight(edge)) {</b>
<b class="nc">&nbsp;            result = refreshTicksVertical(g2, dataArea, edge);</b>
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Returns a list of ticks for an axis at the top or bottom of the chart.
&nbsp;     *
&nbsp;     * @param g2  the graphics device ({@code null} not permitted).
&nbsp;     * @param dataArea  the data area ({@code null} not permitted).
&nbsp;     * @param edge  the edge ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @return A list of ticks.
&nbsp;     */
&nbsp;    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,
&nbsp;            RectangleEdge edge) {
&nbsp;
<b class="fc">&nbsp;        Range range = getRange();</b>
<b class="fc">&nbsp;        List ticks = new ArrayList();</b>
<b class="fc">&nbsp;        Font tickLabelFont = getTickLabelFont();</b>
<b class="fc">&nbsp;        g2.setFont(tickLabelFont);</b>
&nbsp;        TextAnchor textAnchor;
<b class="fc">&nbsp;        if (edge == RectangleEdge.TOP) {</b>
<b class="fc">&nbsp;            textAnchor = TextAnchor.BOTTOM_CENTER;</b>
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;            textAnchor = TextAnchor.TOP_CENTER;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (isAutoTickUnitSelection()) {</b>
<b class="fc">&nbsp;            selectAutoTickUnit(g2, dataArea, edge);</b>
&nbsp;        }
<b class="fc">&nbsp;        int minorTickCount = this.tickUnit.getMinorTickCount();</b>
<b class="fc">&nbsp;        double unit = getTickUnit().getSize();</b>
<b class="fc">&nbsp;        double index = Math.ceil(calculateLog(getRange().getLowerBound()) </b>
&nbsp;                / unit);
<b class="fc">&nbsp;        double start = index * unit;</b>
<b class="fc">&nbsp;        double end = calculateLog(getUpperBound());</b>
<b class="fc">&nbsp;        double current = start;</b>
<b class="fc">&nbsp;        boolean hasTicks = (this.tickUnit.getSize() &gt; 0.0)</b>
<b class="fc">&nbsp;                           &amp;&amp; !Double.isInfinite(start);</b>
<b class="fc">&nbsp;        while (hasTicks &amp;&amp; current &lt;= end) {</b>
<b class="nc">&nbsp;            double v = calculateValueNoINF(current);</b>
<b class="nc">&nbsp;            if (range.contains(v)) {</b>
<b class="nc">&nbsp;                ticks.add(new LogTick(TickType.MAJOR, v, createTickLabel(v),</b>
&nbsp;                        textAnchor));
&nbsp;            }
&nbsp;            // add minor ticks (for gridlines)
<b class="nc">&nbsp;            double next = Math.pow(this.base, current</b>
<b class="nc">&nbsp;                    + this.tickUnit.getSize());</b>
<b class="nc">&nbsp;            for (int i = 1; i &lt; minorTickCount; i++) {</b>
<b class="nc">&nbsp;                double minorV = v + i * ((next - v) / minorTickCount);</b>
<b class="nc">&nbsp;                if (range.contains(minorV)) {</b>
<b class="nc">&nbsp;                    ticks.add(new LogTick(TickType.MINOR, minorV, null,</b>
&nbsp;                            textAnchor));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            current = current + this.tickUnit.getSize();</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        return ticks;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of ticks for an axis at the left or right of the chart.
&nbsp;     *
&nbsp;     * @param g2  the graphics device ({@code null} not permitted).
&nbsp;     * @param dataArea  the data area ({@code null} not permitted).
&nbsp;     * @param edge  the edge that the axis is aligned to ({@code null} 
&nbsp;     *     not permitted).
&nbsp;     *
&nbsp;     * @return A list of ticks.
&nbsp;     */
&nbsp;    protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,
&nbsp;            RectangleEdge edge) {
&nbsp;
<b class="nc">&nbsp;        Range range = getRange();</b>
<b class="nc">&nbsp;        List ticks = new ArrayList();</b>
<b class="nc">&nbsp;        Font tickLabelFont = getTickLabelFont();</b>
<b class="nc">&nbsp;        g2.setFont(tickLabelFont);</b>
&nbsp;        TextAnchor textAnchor;
<b class="nc">&nbsp;        if (edge == RectangleEdge.RIGHT) {</b>
<b class="nc">&nbsp;            textAnchor = TextAnchor.CENTER_LEFT;</b>
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;            textAnchor = TextAnchor.CENTER_RIGHT;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isAutoTickUnitSelection()) {</b>
<b class="nc">&nbsp;            selectAutoTickUnit(g2, dataArea, edge);</b>
&nbsp;        }
<b class="nc">&nbsp;        int minorTickCount = this.tickUnit.getMinorTickCount();</b>
<b class="nc">&nbsp;        double unit = getTickUnit().getSize();</b>
<b class="nc">&nbsp;        double index = Math.ceil(calculateLog(getRange().getLowerBound()) </b>
&nbsp;                / unit);
<b class="nc">&nbsp;        double start = index * unit;</b>
<b class="nc">&nbsp;        double end = calculateLog(getUpperBound());</b>
<b class="nc">&nbsp;        double current = start;</b>
<b class="nc">&nbsp;        boolean hasTicks = (this.tickUnit.getSize() &gt; 0.0)</b>
<b class="nc">&nbsp;                           &amp;&amp; !Double.isInfinite(start);</b>
<b class="nc">&nbsp;        while (hasTicks &amp;&amp; current &lt;= end) {</b>
<b class="nc">&nbsp;            double v = calculateValueNoINF(current);</b>
<b class="nc">&nbsp;            if (range.contains(v)) {</b>
<b class="nc">&nbsp;                ticks.add(new LogTick(TickType.MAJOR, v, createTickLabel(v),</b>
&nbsp;                        textAnchor));
&nbsp;            }
&nbsp;            // add minor ticks (for gridlines)
<b class="nc">&nbsp;            double next = Math.pow(this.base, current</b>
<b class="nc">&nbsp;                    + this.tickUnit.getSize());</b>
<b class="nc">&nbsp;            for (int i = 1; i &lt; minorTickCount; i++) {</b>
<b class="nc">&nbsp;                double minorV = v + i * ((next - v) / minorTickCount);</b>
<b class="nc">&nbsp;                if (range.contains(minorV)) {</b>
<b class="nc">&nbsp;                    ticks.add(new LogTick(TickType.MINOR, minorV, null,</b>
&nbsp;                            textAnchor));
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            current = current + this.tickUnit.getSize();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return ticks;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Selects an appropriate tick value for the axis.  The strategy is to
&nbsp;     * display as many ticks as possible (selected from an array of &#39;standard&#39;
&nbsp;     * tick units) without the labels overlapping.
&nbsp;     *
&nbsp;     * @param g2  the graphics device ({@code null} not permitted).
&nbsp;     * @param dataArea  the area defined by the axes ({@code null} not 
&nbsp;     *     permitted).
&nbsp;     * @param edge  the axis location ({@code null} not permitted).
&nbsp;     */
&nbsp;    protected void selectAutoTickUnit(Graphics2D g2, Rectangle2D dataArea,
&nbsp;            RectangleEdge edge) {
<b class="fc">&nbsp;        if (RectangleEdge.isTopOrBottom(edge)) {</b>
<b class="fc">&nbsp;            selectHorizontalAutoTickUnit(g2, dataArea, edge);</b>
&nbsp;        }
<b class="nc">&nbsp;        else if (RectangleEdge.isLeftOrRight(edge)) {</b>
<b class="nc">&nbsp;            selectVerticalAutoTickUnit(g2, dataArea, edge);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Selects an appropriate tick value for the axis.  The strategy is to
&nbsp;     * display as many ticks as possible (selected from an array of &#39;standard&#39;
&nbsp;     * tick units) without the labels overlapping.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param dataArea  the area defined by the axes.
&nbsp;     * @param edge  the axis location.
&nbsp;     */
&nbsp;    protected void selectHorizontalAutoTickUnit(Graphics2D g2,
&nbsp;            Rectangle2D dataArea, RectangleEdge edge) {
&nbsp;
&nbsp;        // select a tick unit that is the next one bigger than the current
&nbsp;        // (log) range divided by 50
<b class="fc">&nbsp;        Range range = getRange();</b>
<b class="fc">&nbsp;        double logAxisMin = calculateLog(Math.max(this.smallestValue, </b>
<b class="fc">&nbsp;                range.getLowerBound()));</b>
<b class="fc">&nbsp;        double logAxisMax = calculateLog(range.getUpperBound());</b>
<b class="fc">&nbsp;        double size = (logAxisMax - logAxisMin) / 50;</b>
<b class="fc">&nbsp;        TickUnitSource tickUnits = getStandardTickUnits();</b>
<b class="fc">&nbsp;        TickUnit candidate = tickUnits.getCeilingTickUnit(size);</b>
<b class="fc">&nbsp;        TickUnit prevCandidate = candidate;</b>
<b class="fc">&nbsp;        boolean found = false;</b>
<b class="fc">&nbsp;        while (!found) {</b>
&nbsp;        // while the tick labels overlap and there are more tick sizes available,
&nbsp;            // choose the next bigger label
<b class="fc">&nbsp;            this.tickUnit = (NumberTickUnit) candidate;</b>
<b class="fc">&nbsp;            double tickLabelWidth = estimateMaximumTickLabelWidth(g2, </b>
&nbsp;                    candidate);
&nbsp;            // what is the available space for one unit?
<b class="fc">&nbsp;            double candidateWidth = exponentLengthToJava2D(candidate.getSize(), </b>
&nbsp;                    dataArea, edge);
<b class="fc">&nbsp;            if (tickLabelWidth &lt; candidateWidth) {</b>
<b class="nc">&nbsp;                found = true;</b>
<b class="fc">&nbsp;            } else if (Double.isNaN(candidateWidth)) {</b>
<b class="fc">&nbsp;                candidate = prevCandidate;</b>
<b class="fc">&nbsp;                found = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                prevCandidate = candidate;</b>
<b class="nc">&nbsp;                candidate = tickUnits.getLargerTickUnit(prevCandidate);</b>
<b class="nc">&nbsp;                if (candidate.equals(prevCandidate)) {</b>
<b class="nc">&nbsp;                    found = true;  // there are no more candidates</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        } </b>
<b class="fc">&nbsp;        setTickUnit((NumberTickUnit) candidate, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a length in data coordinates into the corresponding length in
&nbsp;     * Java2D coordinates.
&nbsp;     *
&nbsp;     * @param length  the length.
&nbsp;     * @param area  the plot area.
&nbsp;     * @param edge  the edge along which the axis lies.
&nbsp;     *
&nbsp;     * @return The length in Java2D coordinates.
&nbsp;     */
&nbsp;    public double exponentLengthToJava2D(double length, Rectangle2D area,
&nbsp;                                RectangleEdge edge) {
<b class="fc">&nbsp;        double one = valueToJava2D(calculateValueNoINF(1.0), area, edge);</b>
<b class="fc">&nbsp;        double l = valueToJava2D(calculateValueNoINF(length + 1.0), area, edge);</b>
<b class="fc">&nbsp;        return Math.abs(l - one);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Selects an appropriate tick value for the axis.  The strategy is to
&nbsp;     * display as many ticks as possible (selected from an array of &#39;standard&#39;
&nbsp;     * tick units) without the labels overlapping.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param dataArea  the area in which the plot should be drawn.
&nbsp;     * @param edge  the axis location.
&nbsp;     */
&nbsp;    protected void selectVerticalAutoTickUnit(Graphics2D g2, 
&nbsp;            Rectangle2D dataArea, RectangleEdge edge) {
&nbsp;        // select a tick unit that is the next one bigger than the current
&nbsp;        // (log) range divided by 50
<b class="nc">&nbsp;        Range range = getRange();</b>
<b class="nc">&nbsp;        double logAxisMin = calculateLog(Math.max(this.smallestValue, </b>
<b class="nc">&nbsp;                range.getLowerBound()));</b>
<b class="nc">&nbsp;        double logAxisMax = calculateLog(range.getUpperBound());</b>
<b class="nc">&nbsp;        double size = (logAxisMax - logAxisMin) / 50;</b>
<b class="nc">&nbsp;        TickUnitSource tickUnits = getStandardTickUnits();</b>
<b class="nc">&nbsp;        TickUnit candidate = tickUnits.getCeilingTickUnit(size);</b>
<b class="nc">&nbsp;        TickUnit prevCandidate = candidate;</b>
<b class="nc">&nbsp;        boolean found = false;</b>
<b class="nc">&nbsp;        while (!found) {</b>
&nbsp;        // while the tick labels overlap and there are more tick sizes available,
&nbsp;            // choose the next bigger label
<b class="nc">&nbsp;            this.tickUnit = (NumberTickUnit) candidate;</b>
<b class="nc">&nbsp;            double tickLabelHeight = estimateMaximumTickLabelHeight(g2);</b>
&nbsp;            // what is the available space for one unit?
<b class="nc">&nbsp;            double candidateHeight = exponentLengthToJava2D(candidate.getSize(), </b>
&nbsp;                    dataArea, edge);
<b class="nc">&nbsp;            if (tickLabelHeight &lt; candidateHeight) {</b>
<b class="nc">&nbsp;                found = true;</b>
<b class="nc">&nbsp;            } else if (Double.isNaN(candidateHeight)) {</b>
<b class="nc">&nbsp;                candidate = prevCandidate;</b>
<b class="nc">&nbsp;                found = true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                prevCandidate = candidate;</b>
<b class="nc">&nbsp;                candidate = tickUnits.getLargerTickUnit(prevCandidate);</b>
<b class="nc">&nbsp;                if (candidate.equals(prevCandidate)) {</b>
<b class="nc">&nbsp;                    found = true;  // there are no more candidates</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } </b>
<b class="nc">&nbsp;        setTickUnit((NumberTickUnit) candidate, false, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a tick label for the specified value based on the current
&nbsp;     * tick unit (used for formatting the exponent).
&nbsp;     *
&nbsp;     * @param value  the value.
&nbsp;     *
&nbsp;     * @return The label.
&nbsp;     */
&nbsp;    protected AttributedString createTickLabel(double value) {
<b class="fc">&nbsp;        if (this.numberFormatOverride != null) {</b>
<b class="nc">&nbsp;            String text = this.numberFormatOverride.format(value);</b>
<b class="nc">&nbsp;            AttributedString as = new AttributedString(text);</b>
<b class="nc">&nbsp;            as.addAttribute(TextAttribute.FONT, getTickLabelFont());</b>
<b class="nc">&nbsp;            return as;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            String baseStr = this.baseSymbol;</b>
<b class="fc">&nbsp;            if (baseStr == null) {</b>
<b class="fc">&nbsp;                baseStr = this.baseFormatter.format(this.base);</b>
&nbsp;            }
<b class="fc">&nbsp;            double logy = calculateLog(value);</b>
<b class="fc">&nbsp;            String exponentStr = getTickUnit().valueToString(logy);</b>
<b class="fc">&nbsp;            AttributedString as = new AttributedString(baseStr + exponentStr);</b>
<b class="fc">&nbsp;            as.addAttributes(getTickLabelFont().getAttributes(), 0, (baseStr </b>
<b class="fc">&nbsp;                    + exponentStr).length());</b>
<b class="fc">&nbsp;            as.addAttribute(TextAttribute.SUPERSCRIPT, </b>
<b class="fc">&nbsp;                    TextAttribute.SUPERSCRIPT_SUPER, baseStr.length(), </b>
<b class="fc">&nbsp;                    baseStr.length() + exponentStr.length());</b>
<b class="fc">&nbsp;            return as;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Estimates the maximum tick label height.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     *
&nbsp;     * @return The maximum height.
&nbsp;     */
&nbsp;    protected double estimateMaximumTickLabelHeight(Graphics2D g2) {
<b class="nc">&nbsp;        RectangleInsets tickLabelInsets = getTickLabelInsets();</b>
<b class="nc">&nbsp;        double result = tickLabelInsets.getTop() + tickLabelInsets.getBottom();</b>
&nbsp;
<b class="nc">&nbsp;        Font tickLabelFont = getTickLabelFont();</b>
<b class="nc">&nbsp;        FontRenderContext frc = g2.getFontRenderContext();</b>
<b class="nc">&nbsp;        result += tickLabelFont.getLineMetrics(&quot;123&quot;, frc).getHeight();</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Estimates the maximum width of the tick labels, assuming the specified
&nbsp;     * tick unit is used.
&nbsp;     * &lt;P&gt;
&nbsp;     * Rather than computing the string bounds of every tick on the axis, we
&nbsp;     * just look at two values: the lower bound and the upper bound for the
&nbsp;     * axis.  These two values will usually be representative.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param unit  the tick unit to use for calculation.
&nbsp;     *
&nbsp;     * @return The estimated maximum width of the tick labels.
&nbsp;     */
&nbsp;    protected double estimateMaximumTickLabelWidth(Graphics2D g2, 
&nbsp;            TickUnit unit) {
&nbsp;
<b class="fc">&nbsp;        RectangleInsets tickLabelInsets = getTickLabelInsets();</b>
<b class="fc">&nbsp;        double result = tickLabelInsets.getLeft() + tickLabelInsets.getRight();</b>
&nbsp;
<b class="fc">&nbsp;        if (isVerticalTickLabels()) {</b>
&nbsp;            // all tick labels have the same width (equal to the height of the
&nbsp;            // font)...
<b class="nc">&nbsp;            FontRenderContext frc = g2.getFontRenderContext();</b>
<b class="nc">&nbsp;            LineMetrics lm = getTickLabelFont().getLineMetrics(&quot;0&quot;, frc);</b>
<b class="nc">&nbsp;            result += lm.getHeight();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        else {
&nbsp;            // look at lower and upper bounds...
<b class="fc">&nbsp;            Range range = getRange();</b>
<b class="fc">&nbsp;            double lower = range.getLowerBound();</b>
<b class="fc">&nbsp;            double upper = range.getUpperBound();</b>
<b class="fc">&nbsp;            AttributedString lowerStr = createTickLabel(lower);</b>
<b class="fc">&nbsp;            AttributedString upperStr = createTickLabel(upper);</b>
<b class="fc">&nbsp;            double w1 = AttrStringUtils.getTextBounds(lowerStr, g2).getWidth();</b>
<b class="fc">&nbsp;            double w2 = AttrStringUtils.getTextBounds(upperStr, g2).getWidth();</b>
<b class="fc">&nbsp;            result += Math.max(w1, w2);</b>
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Zooms in on the current range.
&nbsp;     *
&nbsp;     * @param lowerPercent  the new lower bound.
&nbsp;     * @param upperPercent  the new upper bound.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void zoomRange(double lowerPercent, double upperPercent) {
<b class="nc">&nbsp;        Range range = getRange();</b>
<b class="nc">&nbsp;        double start = range.getLowerBound();</b>
<b class="nc">&nbsp;        double end = range.getUpperBound();</b>
<b class="nc">&nbsp;        double log1 = calculateLog(start);</b>
<b class="nc">&nbsp;        double log2 = calculateLog(end);</b>
<b class="nc">&nbsp;        double length = log2 - log1;</b>
&nbsp;        Range adjusted;
<b class="nc">&nbsp;        if (isInverted()) {</b>
<b class="nc">&nbsp;            double logA = log1 + length * (1 - upperPercent);</b>
<b class="nc">&nbsp;            double logB = log1 + length * (1 - lowerPercent);</b>
<b class="nc">&nbsp;            adjusted = new Range(calculateValueNoINF(logA), </b>
<b class="nc">&nbsp;                    calculateValueNoINF(logB));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        else {
<b class="nc">&nbsp;            double logA = log1 + length * lowerPercent;</b>
<b class="nc">&nbsp;            double logB = log1 + length * upperPercent;</b>
<b class="nc">&nbsp;            adjusted = new Range(calculateValueNoINF(logA), </b>
<b class="nc">&nbsp;                    calculateValueNoINF(logB));</b>
&nbsp;        }
<b class="nc">&nbsp;        setRange(adjusted);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Slides the axis range by the specified percentage.
&nbsp;     *
&nbsp;     * @param percent  the percentage.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void pan(double percent) {
<b class="nc">&nbsp;        Range range = getRange();</b>
<b class="nc">&nbsp;        double lower = range.getLowerBound();</b>
<b class="nc">&nbsp;        double upper = range.getUpperBound();</b>
<b class="nc">&nbsp;        double log1 = calculateLog(lower);</b>
<b class="nc">&nbsp;        double log2 = calculateLog(upper);</b>
<b class="nc">&nbsp;        double length = log2 - log1;</b>
<b class="nc">&nbsp;        double adj = length * percent;</b>
<b class="nc">&nbsp;        log1 = log1 + adj;</b>
<b class="nc">&nbsp;        log2 = log2 + adj;</b>
<b class="nc">&nbsp;        setRange(calculateValueNoINF(log1), calculateValueNoINF(log2));</b>
&nbsp;    }
&nbsp;    
&nbsp;    /**
&nbsp;     * Increases or decreases the axis range by the specified percentage about
&nbsp;     * the central value and sends an {@link AxisChangeEvent} to all registered
&nbsp;     * listeners.
&nbsp;     * &lt;P&gt;
&nbsp;     * To double the length of the axis range, use 200% (2.0).
&nbsp;     * To halve the length of the axis range, use 50% (0.5).
&nbsp;     *
&nbsp;     * @param percent  the resize factor.
&nbsp;     *
&nbsp;     * @see #resizeRange(double, double)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void resizeRange(double percent) {
<b class="nc">&nbsp;        Range range = getRange();</b>
<b class="nc">&nbsp;        double logMin = calculateLog(range.getLowerBound());</b>
<b class="nc">&nbsp;        double logMax = calculateLog(range.getUpperBound());</b>
<b class="nc">&nbsp;        double centralValue = calculateValueNoINF((logMin + logMax) / 2.0);</b>
<b class="nc">&nbsp;        resizeRange(percent, centralValue);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void resizeRange(double percent, double anchorValue) {
<b class="nc">&nbsp;        resizeRange2(percent, anchorValue);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resizes the axis length to the specified percentage of the current
&nbsp;     * range and sends a change event to all registered listeners.  If 
&nbsp;     * {@code percent} is greater than 1.0 (100 percent) then the axis
&nbsp;     * range is increased (which has the effect of zooming out), while if the
&nbsp;     * {@code percent} is less than 1.0 the axis range is decreased 
&nbsp;     * (which has the effect of zooming in).  The resize occurs around an 
&nbsp;     * anchor value (which may not be in the center of the axis).  This is used
&nbsp;     * to support mouse wheel zooming around an arbitrary point on the plot.
&nbsp;     * &lt;br&gt;&lt;br&gt;
&nbsp;     * This method is overridden to perform the percentage calculations on the
&nbsp;     * log values (which are linear for this axis).
&nbsp;     * 
&nbsp;     * @param percent  the percentage (must be greater than zero).
&nbsp;     * @param anchorValue  the anchor value.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void resizeRange2(double percent, double anchorValue) {
<b class="nc">&nbsp;        if (percent &gt; 0.0) {</b>
<b class="nc">&nbsp;            double logAnchorValue = calculateLog(anchorValue);</b>
<b class="nc">&nbsp;            Range range = getRange();</b>
<b class="nc">&nbsp;            double logAxisMin = calculateLog(range.getLowerBound());</b>
<b class="nc">&nbsp;            double logAxisMax = calculateLog(range.getUpperBound());</b>
&nbsp;
<b class="nc">&nbsp;            double left = percent * (logAnchorValue - logAxisMin);</b>
<b class="nc">&nbsp;            double right = percent * (logAxisMax - logAnchorValue);</b>
&nbsp;            
<b class="nc">&nbsp;            double upperBound = calculateValueNoINF(logAnchorValue + right);</b>
<b class="nc">&nbsp;            Range adjusted = new Range(calculateValueNoINF(</b>
&nbsp;                    logAnchorValue - left), upperBound);
<b class="nc">&nbsp;            setRange(adjusted);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        else {
<b class="nc">&nbsp;            setAutoRange(true);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tests this axis for equality with an arbitrary object.
&nbsp;     *
&nbsp;     * @param obj  the object ({@code null} permitted).
&nbsp;     *
&nbsp;     * @return A boolean.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(Object obj) {
<b class="fc">&nbsp;        if (obj == this) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!(obj instanceof LogAxis)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        LogAxis that = (LogAxis) obj;</b>
<b class="fc">&nbsp;        if (this.base != that.base) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.baseSymbol, that.baseSymbol)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!this.baseFormatter.equals(that.baseFormatter)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.smallestValue != that.smallestValue) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.numberFormatOverride, that.numberFormatOverride)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return super.equals(obj);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a hash code for this instance.
&nbsp;     *
&nbsp;     * @return A hash code.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="fc">&nbsp;        int result = 193;</b>
<b class="fc">&nbsp;        long temp = Double.doubleToLongBits(this.base);</b>
<b class="fc">&nbsp;        result = 37 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</b>
<b class="fc">&nbsp;        temp = Double.doubleToLongBits(this.smallestValue);</b>
<b class="fc">&nbsp;        result = 37 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</b>
<b class="fc">&nbsp;        if (this.numberFormatOverride != null) {</b>
<b class="nc">&nbsp;            result = 37 * result + this.numberFormatOverride.hashCode();</b>
&nbsp;        }
<b class="fc">&nbsp;        result = 37 * result + this.tickUnit.hashCode();</b>
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-10-20 10:57</div>
</div>
</body>
</html>
