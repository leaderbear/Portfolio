


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SpiderWebPlot</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jfree.chart.plot</a>
</div>

<h1>Coverage Summary for Class: SpiderWebPlot (org.jfree.chart.plot)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SpiderWebPlot</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74,6%
  </span>
  <span class="absValue">
    (47/63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85,5%
  </span>
  <span class="absValue">
    (337/394)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* ===========================================================
&nbsp; * JFreeChart : a free chart library for the Java(tm) platform
&nbsp; * ===========================================================
&nbsp; *
&nbsp; * (C) Copyright 2000-2022, by David Gilbert and Contributors.
&nbsp; *
&nbsp; * Project Info:  http://www.jfree.org/jfreechart/index.html
&nbsp; *
&nbsp; * This library is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU Lesser General Public License as published by
&nbsp; * the Free Software Foundation; either version 2.1 of the License, or
&nbsp; * (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful, but
&nbsp; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
&nbsp; * License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
&nbsp; * USA.
&nbsp; *
&nbsp; * [Oracle and Java are registered trademarks of Oracle and/or its affiliates.
&nbsp; * Other names may be trademarks of their respective owners.]
&nbsp; *
&nbsp; * ------------------
&nbsp; * SpiderWebPlot.java
&nbsp; * ------------------
&nbsp; * (C) Copyright 2005-2021, by Heaps of Flavour Pty Ltd and Contributors.
&nbsp; *
&nbsp; * Company Info:  http://www.i4-talent.com
&nbsp; *
&nbsp; * Original Author:  Don Elliott;
&nbsp; * Contributor(s):   David Gilbert;
&nbsp; *                   Nina Jeliazkova;
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.jfree.chart.plot;
&nbsp;
&nbsp;import org.jfree.chart.api.RectangleInsets;
&nbsp;import org.jfree.chart.api.Rotation;
&nbsp;import org.jfree.chart.api.TableOrder;
&nbsp;import org.jfree.chart.entity.CategoryItemEntity;
&nbsp;import org.jfree.chart.entity.EntityCollection;
&nbsp;import org.jfree.chart.event.PlotChangeEvent;
&nbsp;import org.jfree.chart.internal.*;
&nbsp;import org.jfree.chart.labels.CategoryItemLabelGenerator;
&nbsp;import org.jfree.chart.labels.CategoryToolTipGenerator;
&nbsp;import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
&nbsp;import org.jfree.chart.legend.LegendItem;
&nbsp;import org.jfree.chart.legend.LegendItemCollection;
&nbsp;import org.jfree.chart.urls.CategoryURLGenerator;
&nbsp;import org.jfree.data.category.CategoryDataset;
&nbsp;import org.jfree.data.general.DatasetChangeEvent;
&nbsp;import org.jfree.data.general.DatasetUtils;
&nbsp;
&nbsp;import java.awt.*;
&nbsp;import java.awt.font.FontRenderContext;
&nbsp;import java.awt.font.LineMetrics;
&nbsp;import java.awt.geom.*;
&nbsp;import java.io.IOException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.List;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * A plot that displays data from a {@link CategoryDataset} in the form of a
&nbsp; * &quot;spider web&quot;.  Multiple series can be plotted on the same axis to allow
&nbsp; * easy comparison.  This plot doesn&#39;t support negative values at present.
&nbsp; */
&nbsp;public class SpiderWebPlot extends Plot implements Cloneable, Serializable {
&nbsp;
&nbsp;    /** For serialization. */
&nbsp;    private static final long serialVersionUID = -5376340422031599463L;
&nbsp;
&nbsp;    /** The default head radius percent (currently 1%). */
&nbsp;    public static final double DEFAULT_HEAD = 0.01;
&nbsp;
&nbsp;    /** The default axis label gap (currently 10%). */
&nbsp;    public static final double DEFAULT_AXIS_LABEL_GAP = 0.10;
&nbsp;
&nbsp;    /** The default interior gap. */
&nbsp;    public static final double DEFAULT_INTERIOR_GAP = 0.25;
&nbsp;
&nbsp;    /** The maximum interior gap (currently 40%). */
&nbsp;    public static final double MAX_INTERIOR_GAP = 0.40;
&nbsp;
&nbsp;    /** The default starting angle for the radar chart axes. */
&nbsp;    public static final double DEFAULT_START_ANGLE = 90.0;
&nbsp;
&nbsp;    /** The default series label font. */
<b class="fc">&nbsp;    public static final Font DEFAULT_LABEL_FONT = new Font(&quot;SansSerif&quot;,</b>
&nbsp;            Font.PLAIN, 10);
&nbsp;
&nbsp;    /** The default series label paint. */
<b class="fc">&nbsp;    public static final Paint  DEFAULT_LABEL_PAINT = Color.BLACK;</b>
&nbsp;
&nbsp;    /** The default series label background paint. */
<b class="fc">&nbsp;    public static final Paint  DEFAULT_LABEL_BACKGROUND_PAINT</b>
&nbsp;            = new Color(255, 255, 192);
&nbsp;
&nbsp;    /** The default series label outline paint. */
<b class="fc">&nbsp;    public static final Paint  DEFAULT_LABEL_OUTLINE_PAINT = Color.BLACK;</b>
&nbsp;
&nbsp;    /** The default series label outline stroke. */
<b class="fc">&nbsp;    public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE</b>
&nbsp;            = new BasicStroke(0.5f);
&nbsp;
&nbsp;    /** The default series label shadow paint. */
<b class="fc">&nbsp;    public static final Paint  DEFAULT_LABEL_SHADOW_PAINT = Color.LIGHT_GRAY;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The default maximum value plotted - forces the plot to evaluate
&nbsp;     *  the maximum from the data passed in
&nbsp;     */
&nbsp;    public static final double DEFAULT_MAX_VALUE = -1.0;
&nbsp;
&nbsp;    /** The head radius as a percentage of the available drawing area. */
&nbsp;    protected double headPercent;
&nbsp;
&nbsp;    /** The space left around the outside of the plot as a percentage. */
&nbsp;    private double interiorGap;
&nbsp;
&nbsp;    /** The gap between the labels and the axes as a %age of the radius. */
&nbsp;    private double axisLabelGap;
&nbsp;
&nbsp;    /** The paint used to draw the axis lines. */
&nbsp;    private transient Paint axisLinePaint;
&nbsp;
&nbsp;    /** The stroke used to draw the axis lines. */
&nbsp;    private transient Stroke axisLineStroke;
&nbsp;
&nbsp;    /** The dataset. */
&nbsp;    private CategoryDataset dataset;
&nbsp;
&nbsp;    /** The maximum value we are plotting against on each category axis */
&nbsp;    private double maxValue;
&nbsp;
&nbsp;    /**
&nbsp;     * The data extract order (BY_ROW or BY_COLUMN). This denotes whether
&nbsp;     * the data series are stored in rows (in which case the category names are
&nbsp;     * derived from the column keys) or in columns (in which case the category
&nbsp;     * names are derived from the row keys).
&nbsp;     */
&nbsp;    private TableOrder dataExtractOrder;
&nbsp;
&nbsp;    /** The starting angle. */
&nbsp;    private double startAngle;
&nbsp;
&nbsp;    /** The direction for drawing the radar axis and plots. */
&nbsp;    private Rotation direction;
&nbsp;
&nbsp;    /** The legend item shape. */
&nbsp;    private transient Shape legendItemShape;
&nbsp;
&nbsp;    /** The series paint list. */
&nbsp;    private transient Map&lt;Integer, Paint&gt; seriesPaints;
&nbsp;
&nbsp;    /** The default series paint. */
&nbsp;    private transient Paint defaultSeriesPaint;
&nbsp;
&nbsp;    /** The series outline paint list. */
&nbsp;    private transient Map&lt;Integer, Paint&gt; seriesOutlinePaints;
&nbsp;
&nbsp;    /** The default series outline paint. */
&nbsp;    private transient Paint defaultSeriesOutlinePaint;
&nbsp;
&nbsp;    /** The series outline stroke list. */
&nbsp;    private transient Map&lt;Integer, Stroke&gt; seriesOutlineStrokes;
&nbsp;
&nbsp;    /** The default series outline stroke. */
&nbsp;    private transient Stroke defaultSeriesOutlineStroke;
&nbsp;
&nbsp;    /** The font used to display the category labels. */
&nbsp;    private Font labelFont;
&nbsp;
&nbsp;    /** The color used to draw the category labels. */
&nbsp;    private transient Paint labelPaint;
&nbsp;
&nbsp;    /** The label generator. */
&nbsp;    private CategoryItemLabelGenerator labelGenerator;
&nbsp;
&nbsp;    /** controls if the web polygons are filled or not */
<b class="fc">&nbsp;    private boolean webFilled = true;</b>
&nbsp;
&nbsp;    /** A tooltip generator for the plot ({@code null} permitted). */
&nbsp;    private CategoryToolTipGenerator toolTipGenerator;
&nbsp;
&nbsp;    /** A URL generator for the plot ({@code null} permitted). */
&nbsp;    private CategoryURLGenerator urlGenerator;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a default plot with no dataset.
&nbsp;     */
&nbsp;    public SpiderWebPlot() {
<b class="nc">&nbsp;        this(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new spider web plot with the given dataset, with each row
&nbsp;     * representing a series.
&nbsp;     *
&nbsp;     * @param dataset  the dataset ({@code null} permitted).
&nbsp;     */
&nbsp;    public SpiderWebPlot(CategoryDataset dataset) {
<b class="fc">&nbsp;        this(dataset, TableOrder.BY_ROW);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new spider web plot with the given dataset.
&nbsp;     *
&nbsp;     * @param dataset  the dataset.
&nbsp;     * @param extract  controls how data is extracted ({@link TableOrder#BY_ROW}
&nbsp;     *                 or {@link TableOrder#BY_COLUMN}).
&nbsp;     */
&nbsp;    public SpiderWebPlot(CategoryDataset dataset, TableOrder extract) {
<b class="fc">&nbsp;        super();</b>
<b class="fc">&nbsp;        Args.nullNotPermitted(extract, &quot;extract&quot;);</b>
<b class="fc">&nbsp;        this.dataset = dataset;</b>
<b class="fc">&nbsp;        if (dataset != null) {</b>
<b class="fc">&nbsp;            dataset.addChangeListener(this);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.dataExtractOrder = extract;</b>
<b class="fc">&nbsp;        this.headPercent = DEFAULT_HEAD;</b>
<b class="fc">&nbsp;        this.axisLabelGap = DEFAULT_AXIS_LABEL_GAP;</b>
<b class="fc">&nbsp;        this.axisLinePaint = Color.BLACK;</b>
<b class="fc">&nbsp;        this.axisLineStroke = new BasicStroke(1.0f);</b>
&nbsp;
<b class="fc">&nbsp;        this.interiorGap = DEFAULT_INTERIOR_GAP;</b>
<b class="fc">&nbsp;        this.startAngle = DEFAULT_START_ANGLE;</b>
<b class="fc">&nbsp;        this.direction = Rotation.CLOCKWISE;</b>
<b class="fc">&nbsp;        this.maxValue = DEFAULT_MAX_VALUE;</b>
&nbsp;
<b class="fc">&nbsp;        this.seriesPaints = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.defaultSeriesPaint = null;</b>
&nbsp;
<b class="fc">&nbsp;        this.seriesOutlinePaints = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.defaultSeriesOutlinePaint = DEFAULT_OUTLINE_PAINT;</b>
&nbsp;
<b class="fc">&nbsp;        this.seriesOutlineStrokes = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.defaultSeriesOutlineStroke = DEFAULT_OUTLINE_STROKE;</b>
&nbsp;
<b class="fc">&nbsp;        this.labelFont = DEFAULT_LABEL_FONT;</b>
<b class="fc">&nbsp;        this.labelPaint = DEFAULT_LABEL_PAINT;</b>
<b class="fc">&nbsp;        this.labelGenerator = new StandardCategoryItemLabelGenerator();</b>
&nbsp;
<b class="fc">&nbsp;        this.legendItemShape = DEFAULT_LEGEND_ITEM_CIRCLE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a short string describing the type of plot.
&nbsp;     *
&nbsp;     * @return The plot type.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getPlotType() {
&nbsp;        // return localizationResources.getString(&quot;Radar_Plot&quot;);
<b class="nc">&nbsp;        return (&quot;Spider Web Plot&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the dataset.
&nbsp;     *
&nbsp;     * @return The dataset (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #setDataset(CategoryDataset)
&nbsp;     */
&nbsp;    public CategoryDataset getDataset() {
<b class="fc">&nbsp;        return this.dataset;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}
&nbsp;     * to all registered listeners.
&nbsp;     *
&nbsp;     * @param dataset  the dataset ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getDataset()
&nbsp;     */
&nbsp;    public void setDataset(CategoryDataset dataset) {
&nbsp;        // if there is an existing dataset, remove the plot from the list of
&nbsp;        // change listeners...
<b class="nc">&nbsp;        if (this.dataset != null) {</b>
<b class="nc">&nbsp;            this.dataset.removeChangeListener(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        // set the new dataset, and register the chart as a change listener...
<b class="nc">&nbsp;        this.dataset = dataset;</b>
<b class="nc">&nbsp;        if (dataset != null) {</b>
<b class="nc">&nbsp;            dataset.addChangeListener(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        // send a dataset change event to self to trigger plot change event
<b class="nc">&nbsp;        datasetChanged(new DatasetChangeEvent(this, dataset));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Method to determine if the web chart is to be filled.
&nbsp;     *
&nbsp;     * @return A boolean.
&nbsp;     *
&nbsp;     * @see #setWebFilled(boolean)
&nbsp;     */
&nbsp;    public boolean isWebFilled() {
<b class="nc">&nbsp;        return this.webFilled;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the webFilled flag and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param flag  the flag.
&nbsp;     *
&nbsp;     * @see #isWebFilled()
&nbsp;     */
&nbsp;    public void setWebFilled(boolean flag) {
<b class="fc">&nbsp;        this.webFilled = flag;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the data extract order (by row or by column).
&nbsp;     *
&nbsp;     * @return The data extract order (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setDataExtractOrder(TableOrder)
&nbsp;     */
&nbsp;    public TableOrder getDataExtractOrder() {
<b class="nc">&nbsp;        return this.dataExtractOrder;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the data extract order (by row or by column) and sends a
&nbsp;     * {@link PlotChangeEvent}to all registered listeners.
&nbsp;     *
&nbsp;     * @param order the order ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException if {@code order} is
&nbsp;     *     {@code null}.
&nbsp;     *
&nbsp;     * @see #getDataExtractOrder()
&nbsp;     */
&nbsp;    public void setDataExtractOrder(TableOrder order) {
<b class="fc">&nbsp;        Args.nullNotPermitted(order, &quot;order&quot;);</b>
<b class="fc">&nbsp;        this.dataExtractOrder = order;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the head percent (the default value is 0.01).
&nbsp;     *
&nbsp;     * @return The head percent (always &gt; 0).
&nbsp;     *
&nbsp;     * @see #setHeadPercent(double)
&nbsp;     */
&nbsp;    public double getHeadPercent() {
<b class="nc">&nbsp;        return this.headPercent;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the head percent and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.  Note that 0.10 is 10 percent.
&nbsp;     *
&nbsp;     * @param percent  the percent (must be greater than zero).
&nbsp;     *
&nbsp;     * @see #getHeadPercent()
&nbsp;     */
&nbsp;    public void setHeadPercent(double percent) {
<b class="fc">&nbsp;        Args.requireNonNegative(percent, &quot;percent&quot;);</b>
<b class="fc">&nbsp;        this.headPercent = percent;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the start angle for the first radar axis.
&nbsp;     * &lt;BR&gt;
&nbsp;     * This is measured in degrees starting from 3 o&#39;clock (Java Arc2D default)
&nbsp;     * and measuring anti-clockwise.
&nbsp;     *
&nbsp;     * @return The start angle.
&nbsp;     *
&nbsp;     * @see #setStartAngle(double)
&nbsp;     */
&nbsp;    public double getStartAngle() {
<b class="fc">&nbsp;        return this.startAngle;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the starting angle and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     * &lt;P&gt;
&nbsp;     * The initial default value is 90 degrees, which corresponds to 12 o&#39;clock.
&nbsp;     * A value of zero corresponds to 3 o&#39;clock... this is the encoding used by
&nbsp;     * Java&#39;s Arc2D class.
&nbsp;     *
&nbsp;     * @param angle  the angle (in degrees).
&nbsp;     *
&nbsp;     * @see #getStartAngle()
&nbsp;     */
&nbsp;    public void setStartAngle(double angle) {
<b class="fc">&nbsp;        this.startAngle = angle;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the maximum value any category axis can take.
&nbsp;     *
&nbsp;     * @return The maximum value.
&nbsp;     *
&nbsp;     * @see #setMaxValue(double)
&nbsp;     */
&nbsp;    public double getMaxValue() {
<b class="nc">&nbsp;        return this.maxValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the maximum value any category axis can take and sends
&nbsp;     * a {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param value  the maximum value.
&nbsp;     *
&nbsp;     * @see #getMaxValue()
&nbsp;     */
&nbsp;    public void setMaxValue(double value) {
<b class="fc">&nbsp;        this.maxValue = value;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the direction in which the radar axes are drawn
&nbsp;     * (clockwise or anti-clockwise).
&nbsp;     *
&nbsp;     * @return The direction (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setDirection(Rotation)
&nbsp;     */
&nbsp;    public Rotation getDirection() {
<b class="fc">&nbsp;        return this.direction;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the direction in which the radar axes are drawn and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param direction  the direction ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getDirection()
&nbsp;     */
&nbsp;    public void setDirection(Rotation direction) {
<b class="fc">&nbsp;        Args.nullNotPermitted(direction, &quot;direction&quot;);</b>
<b class="fc">&nbsp;        this.direction = direction;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the interior gap, measured as a percentage of the available
&nbsp;     * drawing space.
&nbsp;     *
&nbsp;     * @return The gap (as a percentage of the available drawing space).
&nbsp;     *
&nbsp;     * @see #setInteriorGap(double)
&nbsp;     */
&nbsp;    public double getInteriorGap() {
<b class="fc">&nbsp;        return this.interiorGap;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the interior gap and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners. This controls the space between the edges of the
&nbsp;     * plot and the plot area itself (the region where the axis labels appear).
&nbsp;     *
&nbsp;     * @param percent  the gap (as a percentage of the available drawing space).
&nbsp;     *
&nbsp;     * @see #getInteriorGap()
&nbsp;     */
&nbsp;    public void setInteriorGap(double percent) {
<b class="fc">&nbsp;        if ((percent &lt; 0.0) || (percent &gt; MAX_INTERIOR_GAP)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Percentage outside valid range.&quot;);
&nbsp;        }
<b class="fc">&nbsp;        if (this.interiorGap != percent) {</b>
<b class="fc">&nbsp;            this.interiorGap = percent;</b>
<b class="fc">&nbsp;            fireChangeEvent();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the axis label gap.
&nbsp;     *
&nbsp;     * @return The axis label gap.
&nbsp;     *
&nbsp;     * @see #setAxisLabelGap(double)
&nbsp;     */
&nbsp;    public double getAxisLabelGap() {
<b class="nc">&nbsp;        return this.axisLabelGap;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the axis label gap and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param gap  the gap.
&nbsp;     *
&nbsp;     * @see #getAxisLabelGap()
&nbsp;     */
&nbsp;    public void setAxisLabelGap(double gap) {
<b class="fc">&nbsp;        this.axisLabelGap = gap;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the paint used to draw the axis lines.
&nbsp;     *
&nbsp;     * @return The paint used to draw the axis lines (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setAxisLinePaint(Paint)
&nbsp;     * @see #getAxisLineStroke()
&nbsp;     */
&nbsp;    public Paint getAxisLinePaint() {
<b class="nc">&nbsp;        return this.axisLinePaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the paint used to draw the axis lines and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getAxisLinePaint()
&nbsp;     */
&nbsp;    public void setAxisLinePaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        this.axisLinePaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the stroke used to draw the axis lines.
&nbsp;     *
&nbsp;     * @return The stroke used to draw the axis lines (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setAxisLineStroke(Stroke)
&nbsp;     * @see #getAxisLinePaint()
&nbsp;     */
&nbsp;    public Stroke getAxisLineStroke() {
<b class="nc">&nbsp;        return this.axisLineStroke;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the stroke used to draw the axis lines and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param stroke  the stroke ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getAxisLineStroke()
&nbsp;     */
&nbsp;    public void setAxisLineStroke(Stroke stroke) {
<b class="fc">&nbsp;        Args.nullNotPermitted(stroke, &quot;stroke&quot;);</b>
<b class="fc">&nbsp;        this.axisLineStroke = stroke;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    //// SERIES PAINT /////////////////////////
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the paint for the specified series.
&nbsp;     *
&nbsp;     * @param series  the series index (zero-based).
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setSeriesPaint(int, Paint)
&nbsp;     */
&nbsp;    public Paint getSeriesPaint(int series) {
&nbsp;        // look up the paint list
<b class="fc">&nbsp;        Paint result = this.seriesPaints.get(series);</b>
<b class="fc">&nbsp;        if (result == null) {</b>
<b class="fc">&nbsp;            DrawingSupplier supplier = getDrawingSupplier();</b>
<b class="fc">&nbsp;            if (supplier != null) {</b>
<b class="fc">&nbsp;                Paint p = supplier.getNextPaint();</b>
<b class="fc">&nbsp;                this.seriesPaints.put(series, p);</b>
<b class="fc">&nbsp;                result = p;</b>
<b class="fc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                result = this.defaultSeriesPaint;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the paint used to fill a series of the radar and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param series  the series index (zero-based).
&nbsp;     * @param paint  the paint ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getSeriesPaint(int)
&nbsp;     */
&nbsp;    public void setSeriesPaint(int series, Paint paint) {
<b class="fc">&nbsp;        this.seriesPaints.put(series, paint);</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default series paint, used when no other paint is
&nbsp;     * available.
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setDefaultSeriesPaint(Paint)
&nbsp;     */
&nbsp;    public Paint getDefaultSeriesPaint() {
<b class="nc">&nbsp;      return this.defaultSeriesPaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the default series paint.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getDefaultSeriesPaint()
&nbsp;     */
&nbsp;    public void setDefaultSeriesPaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        this.defaultSeriesPaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    //// SERIES OUTLINE PAINT ////////////////////////////
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the paint for the specified series.
&nbsp;     *
&nbsp;     * @param series  the series index (zero-based).
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     */
&nbsp;    public Paint getSeriesOutlinePaint(int series) {
&nbsp;        // otherwise look up the paint list
<b class="fc">&nbsp;        Paint result = this.seriesOutlinePaints.get(series);</b>
<b class="fc">&nbsp;        if (result == null) {</b>
<b class="fc">&nbsp;            result = this.defaultSeriesOutlinePaint;</b>
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the paint used to fill a series of the radar and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param series  the series index (zero-based).
&nbsp;     * @param paint  the paint ({@code null} permitted).
&nbsp;     */
&nbsp;    public void setSeriesOutlinePaint(int series, Paint paint) {
<b class="fc">&nbsp;        this.seriesOutlinePaints.put(series, paint);</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the base series paint. This is used when no other paint is
&nbsp;     * available.
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     */
&nbsp;    public Paint getDefaultSeriesOutlinePaint() {
<b class="nc">&nbsp;        return this.defaultSeriesOutlinePaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the base series paint and sends a change event to all registered
&nbsp;     * listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     */
&nbsp;    public void setDefaultSeriesOutlinePaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        this.defaultSeriesOutlinePaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    //// SERIES OUTLINE STROKE /////////////////////
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the stroke for the specified series.
&nbsp;     *
&nbsp;     * @param series  the series index (zero-based).
&nbsp;     *
&nbsp;     * @return The stroke (never {@code null}).
&nbsp;     */
&nbsp;    public Stroke getSeriesOutlineStroke(int series) {
<b class="fc">&nbsp;        Stroke result = this.seriesOutlineStrokes.get(series);</b>
<b class="fc">&nbsp;        if (result == null) {</b>
<b class="fc">&nbsp;            result = this.defaultSeriesOutlineStroke;</b>
&nbsp;        }
<b class="fc">&nbsp;        return result;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the stroke used to fill a series of the radar and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param series  the series index (zero-based).
&nbsp;     * @param stroke  the stroke ({@code null} permitted).
&nbsp;     */
&nbsp;    public void setSeriesOutlineStroke(int series, Stroke stroke) {
<b class="fc">&nbsp;        this.seriesOutlineStrokes.put(series, stroke);</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default series stroke. This is used when no other stroke is
&nbsp;     * available.
&nbsp;     *
&nbsp;     * @return The stroke (never {@code null}).
&nbsp;     */
&nbsp;    public Stroke getDefaultSeriesOutlineStroke() {
<b class="nc">&nbsp;        return this.defaultSeriesOutlineStroke;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the default series stroke and sends a change event to all 
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param stroke  the stroke ({@code null} not permitted).
&nbsp;     */
&nbsp;    public void setDefaultSeriesOutlineStroke(Stroke stroke) {
<b class="fc">&nbsp;        Args.nullNotPermitted(stroke, &quot;stroke&quot;);</b>
<b class="fc">&nbsp;        this.defaultSeriesOutlineStroke = stroke;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the shape used for legend items.
&nbsp;     *
&nbsp;     * @return The shape (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setLegendItemShape(Shape)
&nbsp;     */
&nbsp;    public Shape getLegendItemShape() {
<b class="fc">&nbsp;        return this.legendItemShape;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the shape used for legend items and sends a {@link PlotChangeEvent}
&nbsp;     * to all registered listeners.
&nbsp;     *
&nbsp;     * @param shape  the shape ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getLegendItemShape()
&nbsp;     */
&nbsp;    public void setLegendItemShape(Shape shape) {
<b class="fc">&nbsp;        Args.nullNotPermitted(shape, &quot;shape&quot;);</b>
<b class="fc">&nbsp;        this.legendItemShape = shape;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the series label font.
&nbsp;     *
&nbsp;     * @return The font (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setLabelFont(Font)
&nbsp;     */
&nbsp;    public Font getLabelFont() {
<b class="fc">&nbsp;        return this.labelFont;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the series label font and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param font  the font ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getLabelFont()
&nbsp;     */
&nbsp;    public void setLabelFont(Font font) {
<b class="fc">&nbsp;        Args.nullNotPermitted(font, &quot;font&quot;);</b>
<b class="fc">&nbsp;        this.labelFont = font;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the series label paint.
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setLabelPaint(Paint)
&nbsp;     */
&nbsp;    public Paint getLabelPaint() {
<b class="fc">&nbsp;        return this.labelPaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the series label paint and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getLabelPaint()
&nbsp;     */
&nbsp;    public void setLabelPaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        this.labelPaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the label generator.
&nbsp;     *
&nbsp;     * @return The label generator (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setLabelGenerator(CategoryItemLabelGenerator)
&nbsp;     */
&nbsp;    public CategoryItemLabelGenerator getLabelGenerator() {
<b class="nc">&nbsp;        return this.labelGenerator;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the label generator and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param generator  the generator ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getLabelGenerator()
&nbsp;     */
&nbsp;    public void setLabelGenerator(CategoryItemLabelGenerator generator) {
<b class="fc">&nbsp;        Args.nullNotPermitted(generator, &quot;generator&quot;);</b>
<b class="fc">&nbsp;        this.labelGenerator = generator;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the tool tip generator for the plot.
&nbsp;     *
&nbsp;     * @return The tool tip generator (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #setToolTipGenerator(CategoryToolTipGenerator)
&nbsp;     */
&nbsp;    public CategoryToolTipGenerator getToolTipGenerator() {
<b class="nc">&nbsp;        return this.toolTipGenerator;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tool tip generator for the plot and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param generator  the generator ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getToolTipGenerator()
&nbsp;     */
&nbsp;    public void setToolTipGenerator(CategoryToolTipGenerator generator) {
<b class="fc">&nbsp;        this.toolTipGenerator = generator;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the URL generator for the plot.
&nbsp;     *
&nbsp;     * @return The URL generator (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #setURLGenerator(CategoryURLGenerator)
&nbsp;     */
&nbsp;    public CategoryURLGenerator getURLGenerator() {
<b class="nc">&nbsp;        return this.urlGenerator;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the URL generator for the plot and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param generator  the generator ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getURLGenerator()
&nbsp;     */
&nbsp;    public void setURLGenerator(CategoryURLGenerator generator) {
<b class="fc">&nbsp;        this.urlGenerator = generator;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a collection of legend items for the spider web chart.
&nbsp;     *
&nbsp;     * @return The legend items (never {@code null}).
&nbsp;     */
&nbsp;    @Override
&nbsp;    public LegendItemCollection getLegendItems() {
<b class="fc">&nbsp;        LegendItemCollection result = new LegendItemCollection();</b>
<b class="fc">&nbsp;        if (getDataset() == null) {</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
<b class="fc">&nbsp;        List keys = null;</b>
<b class="fc">&nbsp;        if (this.dataExtractOrder == TableOrder.BY_ROW) {</b>
<b class="fc">&nbsp;            keys = this.dataset.getRowKeys();</b>
&nbsp;        }
<b class="nc">&nbsp;        else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {</b>
<b class="nc">&nbsp;            keys = this.dataset.getColumnKeys();</b>
&nbsp;        }
<b class="fc">&nbsp;        if (keys == null) {</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int series = 0;</b>
<b class="fc">&nbsp;        Iterator iterator = keys.iterator();</b>
<b class="fc">&nbsp;        Shape shape = getLegendItemShape();</b>
<b class="fc">&nbsp;        while (iterator.hasNext()) {</b>
<b class="fc">&nbsp;            Comparable key = (Comparable) iterator.next();</b>
<b class="fc">&nbsp;            String label = key.toString();</b>
<b class="fc">&nbsp;            String description = label;</b>
<b class="fc">&nbsp;            Paint paint = getSeriesPaint(series);</b>
<b class="fc">&nbsp;            Paint outlinePaint = getSeriesOutlinePaint(series);</b>
<b class="fc">&nbsp;            Stroke stroke = getSeriesOutlineStroke(series);</b>
<b class="fc">&nbsp;            LegendItem item = new LegendItem(label, description,</b>
&nbsp;                    null, null, shape, paint, stroke, outlinePaint);
<b class="fc">&nbsp;            item.setDataset(getDataset());</b>
<b class="fc">&nbsp;            item.setSeriesKey(key);</b>
<b class="fc">&nbsp;            item.setSeriesIndex(series);</b>
<b class="fc">&nbsp;            result.add(item);</b>
<b class="fc">&nbsp;            series++;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a cartesian point from a polar angle, length and bounding box
&nbsp;     *
&nbsp;     * @param bounds  the area inside which the point needs to be.
&nbsp;     * @param angle  the polar angle, in degrees.
&nbsp;     * @param length  the relative length. Given in percent of maximum extend.
&nbsp;     *
&nbsp;     * @return The cartesian point.
&nbsp;     */
&nbsp;    protected Point2D getWebPoint(Rectangle2D bounds,
&nbsp;                                  double angle, double length) {
&nbsp;
<b class="fc">&nbsp;        double angrad = Math.toRadians(angle);</b>
<b class="fc">&nbsp;        double x = Math.cos(angrad) * length * bounds.getWidth() / 2;</b>
<b class="fc">&nbsp;        double y = -Math.sin(angrad) * length * bounds.getHeight() / 2;</b>
&nbsp;
<b class="fc">&nbsp;        return new Point2D.Double(bounds.getX() + x + bounds.getWidth() / 2,</b>
<b class="fc">&nbsp;                bounds.getY() + y + bounds.getHeight() / 2);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the plot on a Java 2D graphics device (such as the screen or a
&nbsp;     * printer).
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param area  the area within which the plot should be drawn.
&nbsp;     * @param anchor  the anchor point ({@code null} permitted).
&nbsp;     * @param parentState  the state from the parent plot, if there is one.
&nbsp;     * @param info  collects info about the drawing.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
&nbsp;            PlotState parentState, PlotRenderingInfo info) {
&nbsp;
&nbsp;        // adjust for insets...
<b class="fc">&nbsp;        RectangleInsets insets = getInsets();</b>
<b class="fc">&nbsp;        insets.trim(area);</b>
&nbsp;
<b class="fc">&nbsp;        if (info != null) {</b>
<b class="nc">&nbsp;            info.setPlotArea(area);</b>
<b class="nc">&nbsp;            info.setDataArea(area);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        drawBackground(g2, area);</b>
<b class="fc">&nbsp;        drawOutline(g2, area);</b>
&nbsp;
<b class="fc">&nbsp;        Shape savedClip = g2.getClip();</b>
&nbsp;
<b class="fc">&nbsp;        g2.clip(area);</b>
<b class="fc">&nbsp;        Composite originalComposite = g2.getComposite();</b>
<b class="fc">&nbsp;        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</b>
<b class="fc">&nbsp;                getForegroundAlpha()));</b>
&nbsp;
<b class="fc">&nbsp;        if (!DatasetUtils.isEmptyOrNull(this.dataset)) {</b>
&nbsp;            int seriesCount, catCount;
&nbsp;
<b class="fc">&nbsp;            if (this.dataExtractOrder == TableOrder.BY_ROW) {</b>
<b class="fc">&nbsp;                seriesCount = this.dataset.getRowCount();</b>
<b class="fc">&nbsp;                catCount = this.dataset.getColumnCount();</b>
&nbsp;            }
&nbsp;            else {
<b class="nc">&nbsp;                seriesCount = this.dataset.getColumnCount();</b>
<b class="nc">&nbsp;                catCount = this.dataset.getRowCount();</b>
&nbsp;            }
&nbsp;
&nbsp;            // ensure we have a maximum value to use on the axes
<b class="fc">&nbsp;            if (this.maxValue == DEFAULT_MAX_VALUE) {</b>
<b class="fc">&nbsp;                calculateMaxValue(seriesCount, catCount);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Next, setup the plot area
&nbsp;
&nbsp;            // adjust the plot area by the interior spacing value
&nbsp;
<b class="fc">&nbsp;            double gapHorizontal = area.getWidth() * getInteriorGap();</b>
<b class="fc">&nbsp;            double gapVertical = area.getHeight() * getInteriorGap();</b>
&nbsp;
<b class="fc">&nbsp;            double X = area.getX() + gapHorizontal / 2;</b>
<b class="fc">&nbsp;            double Y = area.getY() + gapVertical / 2;</b>
<b class="fc">&nbsp;            double W = area.getWidth() - gapHorizontal;</b>
<b class="fc">&nbsp;            double H = area.getHeight() - gapVertical;</b>
&nbsp;
<b class="fc">&nbsp;            double headW = area.getWidth() * this.headPercent;</b>
<b class="fc">&nbsp;            double headH = area.getHeight() * this.headPercent;</b>
&nbsp;
&nbsp;            // make the chart area a square
<b class="fc">&nbsp;            double min = Math.min(W, H) / 2;</b>
<b class="fc">&nbsp;            X = (X + X + W) / 2 - min;</b>
<b class="fc">&nbsp;            Y = (Y + Y + H) / 2 - min;</b>
<b class="fc">&nbsp;            W = 2 * min;</b>
<b class="fc">&nbsp;            H = 2 * min;</b>
&nbsp;
<b class="fc">&nbsp;            Point2D  centre = new Point2D.Double(X + W / 2, Y + H / 2);</b>
<b class="fc">&nbsp;            Rectangle2D radarArea = new Rectangle2D.Double(X, Y, W, H);</b>
&nbsp;
&nbsp;            // draw the axis and category label
<b class="fc">&nbsp;            for (int cat = 0; cat &lt; catCount; cat++) {</b>
<b class="fc">&nbsp;                double angle = getStartAngle()</b>
<b class="fc">&nbsp;                        + (getDirection().getFactor() * cat * 360 / catCount);</b>
&nbsp;
<b class="fc">&nbsp;                Point2D endPoint = getWebPoint(radarArea, angle, 1);</b>
&nbsp;                                                     // 1 = end of axis
<b class="fc">&nbsp;                Line2D  line = new Line2D.Double(centre, endPoint);</b>
<b class="fc">&nbsp;                g2.setPaint(this.axisLinePaint);</b>
<b class="fc">&nbsp;                g2.setStroke(this.axisLineStroke);</b>
<b class="fc">&nbsp;                g2.draw(line);</b>
<b class="fc">&nbsp;                drawLabel(g2, radarArea, 0.0, cat, angle, 360.0 / catCount);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Now actually plot each of the series polygons..
<b class="fc">&nbsp;            for (int series = 0; series &lt; seriesCount; series++) {</b>
<b class="fc">&nbsp;                drawRadarPoly(g2, radarArea, centre, info, series, catCount,</b>
&nbsp;                        headH, headW);
&nbsp;            }
<b class="fc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            drawNoDataMessage(g2, area);</b>
&nbsp;        }
<b class="fc">&nbsp;        g2.setClip(savedClip);</b>
<b class="fc">&nbsp;        g2.setComposite(originalComposite);</b>
<b class="fc">&nbsp;        drawOutline(g2, area);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * loop through each of the series to get the maximum value
&nbsp;     * on each category axis
&nbsp;     *
&nbsp;     * @param seriesCount  the number of series
&nbsp;     * @param catCount  the number of categories
&nbsp;     */
&nbsp;    private void calculateMaxValue(int seriesCount, int catCount) {
&nbsp;        double v;
&nbsp;        Number nV;
&nbsp;
<b class="fc">&nbsp;        for (int seriesIndex = 0; seriesIndex &lt; seriesCount; seriesIndex++) {</b>
<b class="fc">&nbsp;            for (int catIndex = 0; catIndex &lt; catCount; catIndex++) {</b>
<b class="fc">&nbsp;                nV = getPlotValue(seriesIndex, catIndex);</b>
<b class="fc">&nbsp;                if (nV != null) {</b>
<b class="fc">&nbsp;                    v = nV.doubleValue();</b>
<b class="fc">&nbsp;                    if (v &gt; this.maxValue) {</b>
<b class="fc">&nbsp;                        this.maxValue = v;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a radar plot polygon.
&nbsp;     *
&nbsp;     * @param g2 the graphics device.
&nbsp;     * @param plotArea the area we are plotting in (already adjusted).
&nbsp;     * @param centre the centre point of the radar axes
&nbsp;     * @param info chart rendering info.
&nbsp;     * @param series the series within the dataset we are plotting
&nbsp;     * @param catCount the number of categories per radar plot
&nbsp;     * @param headH the data point height
&nbsp;     * @param headW the data point width
&nbsp;     */
&nbsp;    protected void drawRadarPoly(Graphics2D g2, Rectangle2D plotArea,
&nbsp;            Point2D centre, PlotRenderingInfo info, int series, int catCount,
&nbsp;            double headH, double headW) {
&nbsp;
<b class="fc">&nbsp;        Polygon polygon = new Polygon();</b>
&nbsp;
<b class="fc">&nbsp;        EntityCollection entities = null;</b>
<b class="fc">&nbsp;        if (info != null) {</b>
<b class="nc">&nbsp;            entities = info.getOwner().getEntityCollection();</b>
&nbsp;        }
&nbsp;
&nbsp;        // plot the data...
<b class="fc">&nbsp;        for (int cat = 0; cat &lt; catCount; cat++) {</b>
&nbsp;
<b class="fc">&nbsp;            Number dataValue = getPlotValue(series, cat);</b>
&nbsp;
<b class="fc">&nbsp;            if (dataValue != null) {</b>
<b class="fc">&nbsp;                double value = dataValue.doubleValue();</b>
&nbsp;
<b class="fc">&nbsp;                if (value &gt;= 0) { // draw the polygon series...</b>
&nbsp;
&nbsp;                    // Finds our starting angle from the centre for this axis
&nbsp;
<b class="fc">&nbsp;                    double angle = getStartAngle()</b>
<b class="fc">&nbsp;                        + (getDirection().getFactor() * cat * 360 / catCount);</b>
&nbsp;
&nbsp;                    // The following angle calc will ensure there isn&#39;t a top
&nbsp;                    // vertical axis - this may be useful if you don&#39;t want any
&nbsp;                    // given criteria to &#39;appear&#39; move important than the
&nbsp;                    // others..
&nbsp;                    //  + (getDirection().getFactor()
&nbsp;                    //        * (cat + 0.5) * 360 / catCount);
&nbsp;
&nbsp;                    // find the point at the appropriate distance end point
&nbsp;                    // along the axis/angle identified above and add it to the
&nbsp;                    // polygon
&nbsp;
<b class="fc">&nbsp;                    Point2D point = getWebPoint(plotArea, angle,</b>
&nbsp;                            value / this.maxValue);
<b class="fc">&nbsp;                    polygon.addPoint((int) point.getX(), (int) point.getY());</b>
&nbsp;
&nbsp;                    // put an elipse at the point being plotted..
&nbsp;
<b class="fc">&nbsp;                    Paint paint = getSeriesPaint(series);</b>
<b class="fc">&nbsp;                    Paint outlinePaint = getSeriesOutlinePaint(series);</b>
<b class="fc">&nbsp;                    Stroke outlineStroke = getSeriesOutlineStroke(series);</b>
&nbsp;
<b class="fc">&nbsp;                    Ellipse2D head = new Ellipse2D.Double(point.getX()</b>
<b class="fc">&nbsp;                            - headW / 2, point.getY() - headH / 2, headW,</b>
&nbsp;                            headH);
<b class="fc">&nbsp;                    g2.setPaint(paint);</b>
<b class="fc">&nbsp;                    g2.fill(head);</b>
<b class="fc">&nbsp;                    g2.setStroke(outlineStroke);</b>
<b class="fc">&nbsp;                    g2.setPaint(outlinePaint);</b>
<b class="fc">&nbsp;                    g2.draw(head);</b>
&nbsp;
<b class="fc">&nbsp;                    if (entities != null) {</b>
&nbsp;                        int row, col;
<b class="nc">&nbsp;                        if (this.dataExtractOrder == TableOrder.BY_ROW) {</b>
<b class="nc">&nbsp;                            row = series;</b>
<b class="nc">&nbsp;                            col = cat;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            row = cat;</b>
<b class="nc">&nbsp;                            col = series;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        String tip = null;</b>
<b class="nc">&nbsp;                        if (this.toolTipGenerator != null) {</b>
<b class="nc">&nbsp;                            tip = this.toolTipGenerator.generateToolTip(</b>
&nbsp;                                    this.dataset, row, col);
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        String url = null;</b>
<b class="nc">&nbsp;                        if (this.urlGenerator != null) {</b>
<b class="nc">&nbsp;                            url = this.urlGenerator.generateURL(this.dataset,</b>
&nbsp;                                   row, col);
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        Shape area = new Rectangle(</b>
<b class="nc">&nbsp;                                (int) (point.getX() - headW),</b>
<b class="nc">&nbsp;                                (int) (point.getY() - headH),</b>
&nbsp;                                (int) (headW * 2), (int) (headH * 2));
<b class="nc">&nbsp;                        CategoryItemEntity entity = new CategoryItemEntity(</b>
&nbsp;                                area, tip, url, this.dataset,
<b class="nc">&nbsp;                                this.dataset.getRowKey(row),</b>
<b class="nc">&nbsp;                                this.dataset.getColumnKey(col));</b>
<b class="nc">&nbsp;                        entities.add(entity);</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        // Plot the polygon
&nbsp;
<b class="fc">&nbsp;        Paint paint = getSeriesPaint(series);</b>
<b class="fc">&nbsp;        g2.setPaint(paint);</b>
<b class="fc">&nbsp;        g2.setStroke(getSeriesOutlineStroke(series));</b>
<b class="fc">&nbsp;        g2.draw(polygon);</b>
&nbsp;
&nbsp;        // Lastly, fill the web polygon if this is required
&nbsp;
<b class="fc">&nbsp;        if (this.webFilled) {</b>
<b class="fc">&nbsp;            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</b>
&nbsp;                    0.1f));
<b class="fc">&nbsp;            g2.fill(polygon);</b>
<b class="fc">&nbsp;            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</b>
<b class="fc">&nbsp;                    getForegroundAlpha()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the value to be plotted at the intersection of the
&nbsp;     * series and the category.  This allows us to plot
&nbsp;     * {@code BY_ROW} or {@code BY_COLUMN} which basically is just
&nbsp;     * reversing the definition of the categories and data series being
&nbsp;     * plotted.
&nbsp;     *
&nbsp;     * @param series the series to be plotted.
&nbsp;     * @param cat the category within the series to be plotted.
&nbsp;     *
&nbsp;     * @return The value to be plotted (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #getDataExtractOrder()
&nbsp;     */
&nbsp;    protected Number getPlotValue(int series, int cat) {
<b class="fc">&nbsp;        Number value = null;</b>
<b class="fc">&nbsp;        if (this.dataExtractOrder == TableOrder.BY_ROW) {</b>
<b class="fc">&nbsp;            value = this.dataset.getValue(series, cat);</b>
<b class="nc">&nbsp;        } else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {</b>
<b class="nc">&nbsp;            value = this.dataset.getValue(cat, series);</b>
&nbsp;        }
<b class="fc">&nbsp;        return value;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the label for one axis.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param plotArea  the plot area
&nbsp;     * @param value  the value of the label (ignored).
&nbsp;     * @param cat  the category (zero-based index).
&nbsp;     * @param startAngle  the starting angle.
&nbsp;     * @param extent  the extent of the arc.
&nbsp;     */
&nbsp;    protected void drawLabel(Graphics2D g2, Rectangle2D plotArea, double value,
&nbsp;                             int cat, double startAngle, double extent) {
<b class="fc">&nbsp;        FontRenderContext frc = g2.getFontRenderContext();</b>
&nbsp;
&nbsp;        String label;
<b class="fc">&nbsp;        if (this.dataExtractOrder == TableOrder.BY_ROW) {</b>
&nbsp;            // if series are in rows, then the categories are the column keys
<b class="fc">&nbsp;            label = this.labelGenerator.generateColumnLabel(this.dataset, cat);</b>
&nbsp;        } else {
&nbsp;            // if series are in columns, then the categories are the row keys
<b class="nc">&nbsp;            label = this.labelGenerator.generateRowLabel(this.dataset, cat);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Rectangle2D labelBounds = getLabelFont().getStringBounds(label, frc);</b>
<b class="fc">&nbsp;        LineMetrics lm = getLabelFont().getLineMetrics(label, frc);</b>
<b class="fc">&nbsp;        double ascent = lm.getAscent();</b>
&nbsp;
<b class="fc">&nbsp;        Point2D labelLocation = calculateLabelLocation(labelBounds, ascent,</b>
&nbsp;                plotArea, startAngle);
&nbsp;
<b class="fc">&nbsp;        Composite saveComposite = g2.getComposite();</b>
&nbsp;
<b class="fc">&nbsp;        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));</b>
<b class="fc">&nbsp;        g2.setPaint(getLabelPaint());</b>
<b class="fc">&nbsp;        g2.setFont(getLabelFont());</b>
<b class="fc">&nbsp;        g2.drawString(label, (float) labelLocation.getX(),</b>
<b class="fc">&nbsp;                (float) labelLocation.getY());</b>
<b class="fc">&nbsp;        g2.setComposite(saveComposite);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the location for a label
&nbsp;     *
&nbsp;     * @param labelBounds the label bounds.
&nbsp;     * @param ascent the ascent (height of font).
&nbsp;     * @param plotArea the plot area
&nbsp;     * @param startAngle the start angle for the pie series.
&nbsp;     *
&nbsp;     * @return The location for a label.
&nbsp;     */
&nbsp;    protected Point2D calculateLabelLocation(Rectangle2D labelBounds,
&nbsp;            double ascent, Rectangle2D plotArea, double startAngle) {
<b class="fc">&nbsp;        Arc2D arc1 = new Arc2D.Double(plotArea, startAngle, 0, Arc2D.OPEN);</b>
<b class="fc">&nbsp;        Point2D point1 = arc1.getEndPoint();</b>
&nbsp;
<b class="fc">&nbsp;        double deltaX = -(point1.getX() - plotArea.getCenterX())</b>
&nbsp;                        * this.axisLabelGap;
<b class="fc">&nbsp;        double deltaY = -(point1.getY() - plotArea.getCenterY())</b>
&nbsp;                        * this.axisLabelGap;
&nbsp;
<b class="fc">&nbsp;        double labelX = point1.getX() - deltaX;</b>
<b class="fc">&nbsp;        double labelY = point1.getY() - deltaY;</b>
&nbsp;
<b class="fc">&nbsp;        if (labelX &lt; plotArea.getCenterX()) {</b>
<b class="fc">&nbsp;            labelX -= labelBounds.getWidth();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (labelX == plotArea.getCenterX()) {</b>
<b class="fc">&nbsp;            labelX -= labelBounds.getWidth() / 2;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (labelY &gt; plotArea.getCenterY()) {</b>
<b class="fc">&nbsp;            labelY += ascent;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return new Point2D.Double(labelX, labelY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tests this plot for equality with an arbitrary object.
&nbsp;     *
&nbsp;     * @param obj  the object ({@code null} permitted).
&nbsp;     *
&nbsp;     * @return A boolean.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(Object obj) {
<b class="fc">&nbsp;        if (obj == this) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!(obj instanceof SpiderWebPlot)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!super.equals(obj)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        SpiderWebPlot that = (SpiderWebPlot) obj;</b>
<b class="fc">&nbsp;        if (!this.dataExtractOrder.equals(that.dataExtractOrder)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.headPercent != that.headPercent) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.interiorGap != that.interiorGap) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.startAngle != that.startAngle) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!this.direction.equals(that.direction)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.maxValue != that.maxValue) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.webFilled != that.webFilled) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.axisLabelGap != that.axisLabelGap) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.axisLinePaint, that.axisLinePaint)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!this.axisLineStroke.equals(that.axisLineStroke)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!ShapeUtils.equal(this.legendItemShape, that.legendItemShape)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.seriesPaints, that.seriesPaints)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.defaultSeriesPaint, that.defaultSeriesPaint)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.seriesOutlinePaints, that.seriesOutlinePaints)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.defaultSeriesOutlinePaint,</b>
&nbsp;                that.defaultSeriesOutlinePaint)) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (!this.seriesOutlineStrokes.equals(that.seriesOutlineStrokes)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!this.defaultSeriesOutlineStroke.equals(that.defaultSeriesOutlineStroke)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!this.labelFont.equals(that.labelFont)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.labelPaint, that.labelPaint)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!this.labelGenerator.equals(that.labelGenerator)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.toolTipGenerator, that.toolTipGenerator)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.urlGenerator, that.urlGenerator)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a clone of this plot.
&nbsp;     *
&nbsp;     * @return A clone of this plot.
&nbsp;     *
&nbsp;     * @throws CloneNotSupportedException if the plot cannot be cloned for
&nbsp;     *         any reason.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Object clone() throws CloneNotSupportedException {
<b class="fc">&nbsp;        SpiderWebPlot clone = (SpiderWebPlot) super.clone();</b>
<b class="fc">&nbsp;        clone.legendItemShape = CloneUtils.clone(this.legendItemShape);</b>
<b class="fc">&nbsp;        clone.seriesPaints = CloneUtils.cloneMapValues(this.seriesPaints);</b>
<b class="fc">&nbsp;        clone.seriesOutlinePaints = CloneUtils.cloneMapValues(this.seriesOutlinePaints);</b>
<b class="fc">&nbsp;        clone.seriesOutlineStrokes = CloneUtils.cloneMapValues(this.seriesOutlineStrokes);</b>
<b class="fc">&nbsp;        return clone;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Provides serialization support.
&nbsp;     *
&nbsp;     * @param stream  the output stream.
&nbsp;     *
&nbsp;     * @throws IOException  if there is an I/O error.
&nbsp;     */
&nbsp;    private void writeObject(ObjectOutputStream stream) throws IOException {
<b class="fc">&nbsp;        stream.defaultWriteObject();</b>
&nbsp;
<b class="fc">&nbsp;        SerialUtils.writeShape(this.legendItemShape, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writeMapOfPaint(this.seriesPaints, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.defaultSeriesPaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writeMapOfPaint(this.seriesOutlinePaints, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.defaultSeriesOutlinePaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writeMapOfStroke(this.seriesOutlineStrokes, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writeStroke(this.defaultSeriesOutlineStroke, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.labelPaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.axisLinePaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writeStroke(this.axisLineStroke, stream);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Provides serialization support.
&nbsp;     *
&nbsp;     * @param stream  the input stream.
&nbsp;     *
&nbsp;     * @throws IOException  if there is an I/O error.
&nbsp;     * @throws ClassNotFoundException  if there is a classpath problem.
&nbsp;     */
&nbsp;    private void readObject(ObjectInputStream stream) throws IOException,
&nbsp;            ClassNotFoundException {
<b class="fc">&nbsp;        stream.defaultReadObject();</b>
&nbsp;
<b class="fc">&nbsp;        this.legendItemShape = SerialUtils.readShape(stream);</b>
<b class="fc">&nbsp;        this.seriesPaints = SerialUtils.readMapOfPaint(stream);</b>
<b class="fc">&nbsp;        this.defaultSeriesPaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.seriesOutlinePaints = SerialUtils.readMapOfPaint(stream);</b>
<b class="fc">&nbsp;        this.defaultSeriesOutlinePaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.seriesOutlineStrokes = SerialUtils.readMapOfStroke(stream);</b>
<b class="fc">&nbsp;        this.defaultSeriesOutlineStroke = SerialUtils.readStroke(stream);</b>
<b class="fc">&nbsp;        this.labelPaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.axisLinePaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.axisLineStroke = SerialUtils.readStroke(stream);</b>
<b class="fc">&nbsp;        if (this.dataset != null) {</b>
<b class="fc">&nbsp;            this.dataset.addChangeListener(this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-10-20 10:57</div>
</div>
</body>
</html>
