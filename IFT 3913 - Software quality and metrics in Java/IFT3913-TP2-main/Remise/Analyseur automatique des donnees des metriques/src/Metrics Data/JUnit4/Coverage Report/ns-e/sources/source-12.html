


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MeterPlot</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jfree.chart.plot</a>
</div>

<h1>Coverage Summary for Class: MeterPlot (org.jfree.chart.plot)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MeterPlot</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67,2%
  </span>
  <span class="absValue">
    (39/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87,8%
  </span>
  <span class="absValue">
    (317/361)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/* ===========================================================
&nbsp; * JFreeChart : a free chart library for the Java(tm) platform
&nbsp; * ===========================================================
&nbsp; *
&nbsp; * (C) Copyright 2000-2022, by David Gilbert and Contributors.
&nbsp; *
&nbsp; * Project Info:  http://www.jfree.org/jfreechart/index.html
&nbsp; *
&nbsp; * This library is free software; you can redistribute it and/or modify it
&nbsp; * under the terms of the GNU Lesser General Public License as published by
&nbsp; * the Free Software Foundation; either version 2.1 of the License, or
&nbsp; * (at your option) any later version.
&nbsp; *
&nbsp; * This library is distributed in the hope that it will be useful, but
&nbsp; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
&nbsp; * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
&nbsp; * License for more details.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Lesser General Public
&nbsp; * License along with this library; if not, write to the Free Software
&nbsp; * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
&nbsp; * USA.
&nbsp; *
&nbsp; * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. 
&nbsp; * Other names may be trademarks of their respective owners.]
&nbsp; *
&nbsp; * --------------
&nbsp; * MeterPlot.java
&nbsp; * --------------
&nbsp; * (C) Copyright 2000-2021, by Hari and Contributors.
&nbsp; *
&nbsp; * Original Author:  Hari (ourhari@hotmail.com);
&nbsp; * Contributor(s):   David Gilbert;
&nbsp; *                   Bob Orchard;
&nbsp; *                   Arnaud Lelievre;
&nbsp; *                   Nicolas Brodu;
&nbsp; *                   David Bastend;
&nbsp; *
&nbsp; */
&nbsp;
&nbsp;package org.jfree.chart.plot;
&nbsp;
&nbsp;import java.awt.AlphaComposite;
&nbsp;import java.awt.BasicStroke;
&nbsp;import java.awt.Color;
&nbsp;import java.awt.Composite;
&nbsp;import java.awt.Font;
&nbsp;import java.awt.FontMetrics;
&nbsp;import java.awt.Graphics2D;
&nbsp;import java.awt.Paint;
&nbsp;import java.awt.Polygon;
&nbsp;import java.awt.Shape;
&nbsp;import java.awt.Stroke;
&nbsp;import java.awt.geom.Arc2D;
&nbsp;import java.awt.geom.Ellipse2D;
&nbsp;import java.awt.geom.Line2D;
&nbsp;import java.awt.geom.Point2D;
&nbsp;import java.awt.geom.Rectangle2D;
&nbsp;import java.io.IOException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.text.NumberFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.ResourceBundle;
&nbsp;
&nbsp;import org.jfree.chart.legend.LegendItem;
&nbsp;import org.jfree.chart.legend.LegendItemCollection;
&nbsp;import org.jfree.chart.event.PlotChangeEvent;
&nbsp;import org.jfree.chart.text.TextUtils;
&nbsp;import org.jfree.chart.api.RectangleInsets;
&nbsp;import org.jfree.chart.text.TextAnchor;
&nbsp;import org.jfree.chart.internal.PaintUtils;
&nbsp;import org.jfree.chart.internal.Args;
&nbsp;import org.jfree.chart.internal.SerialUtils;
&nbsp;import org.jfree.data.Range;
&nbsp;import org.jfree.data.general.DatasetChangeEvent;
&nbsp;import org.jfree.data.general.ValueDataset;
&nbsp;
&nbsp;/**
&nbsp; * A plot that displays a single value in the form of a needle on a dial.
&nbsp; * Defined ranges (for example, &#39;normal&#39;, &#39;warning&#39; and &#39;critical&#39;) can be
&nbsp; * highlighted on the dial.
&nbsp; */
&nbsp;public class MeterPlot extends Plot implements Serializable, Cloneable {
&nbsp;
&nbsp;    /** For serialization. */
&nbsp;    private static final long serialVersionUID = 2987472457734470962L;
&nbsp;
&nbsp;    /** The default background paint. */
<b class="fc">&nbsp;    static final Paint DEFAULT_DIAL_BACKGROUND_PAINT = Color.BLACK;</b>
&nbsp;
&nbsp;    /** The default needle paint. */
<b class="fc">&nbsp;    static final Paint DEFAULT_NEEDLE_PAINT = Color.GREEN;</b>
&nbsp;
&nbsp;    /** The default value font. */
<b class="fc">&nbsp;    static final Font DEFAULT_VALUE_FONT = new Font(&quot;SansSerif&quot;, Font.BOLD, 12);</b>
&nbsp;
&nbsp;    /** The default value paint. */
<b class="fc">&nbsp;    static final Paint DEFAULT_VALUE_PAINT = Color.YELLOW;</b>
&nbsp;
&nbsp;    /** The default meter angle. */
&nbsp;    public static final int DEFAULT_METER_ANGLE = 270;
&nbsp;
&nbsp;    /** The default border size. */
&nbsp;    public static final float DEFAULT_BORDER_SIZE = 3f;
&nbsp;
&nbsp;    /** The default circle size. */
&nbsp;    public static final float DEFAULT_CIRCLE_SIZE = 10f;
&nbsp;
&nbsp;    /** The default label font. */
<b class="fc">&nbsp;    public static final Font DEFAULT_LABEL_FONT = new Font(&quot;SansSerif&quot;,</b>
&nbsp;            Font.BOLD, 10);
&nbsp;
&nbsp;    /** The dataset (contains a single value). */
&nbsp;    private ValueDataset dataset;
&nbsp;
&nbsp;    /** The dial shape (background shape). */
&nbsp;    private DialShape shape;
&nbsp;
&nbsp;    /** The dial extent (measured in degrees). */
&nbsp;    private int meterAngle;
&nbsp;
&nbsp;    /** The overall range of data values on the dial. */
&nbsp;    private Range range;
&nbsp;
&nbsp;    /** The tick size. */
&nbsp;    private double tickSize;
&nbsp;
&nbsp;    /** The paint used to draw the ticks. */
&nbsp;    private transient Paint tickPaint;
&nbsp;
&nbsp;    /** The units displayed on the dial. */
&nbsp;    private String units;
&nbsp;
&nbsp;    /** The font for the value displayed in the center of the dial. */
&nbsp;    private Font valueFont;
&nbsp;
&nbsp;    /** The paint for the value displayed in the center of the dial. */
&nbsp;    private transient Paint valuePaint;
&nbsp;
&nbsp;    /** A flag that indicates whether the value is visible. */
<b class="fc">&nbsp;    private boolean valueVisible = true;</b>
&nbsp;
&nbsp;    /** A flag that controls whether or not the border is drawn. */
&nbsp;    private boolean drawBorder;
&nbsp;
&nbsp;    /** The outline paint. */
&nbsp;    private transient Paint dialOutlinePaint;
&nbsp;
&nbsp;    /** The paint for the dial background. */
&nbsp;    private transient Paint dialBackgroundPaint;
&nbsp;
&nbsp;    /** The paint for the needle. */
&nbsp;    private transient Paint needlePaint;
&nbsp;
&nbsp;    /** A flag that controls whether or not the tick labels are visible. */
&nbsp;    private boolean tickLabelsVisible;
&nbsp;
&nbsp;    /** The tick label font. */
&nbsp;    private Font tickLabelFont;
&nbsp;
&nbsp;    /** The tick label paint. */
&nbsp;    private transient Paint tickLabelPaint;
&nbsp;
&nbsp;    /** The tick label format. */
&nbsp;    private NumberFormat tickLabelFormat;
&nbsp;
&nbsp;    /** The resourceBundle for the localization. */
<b class="fc">&nbsp;    protected static ResourceBundle localizationResources</b>
<b class="fc">&nbsp;            = ResourceBundle.getBundle(&quot;org.jfree.chart.plot.LocalizationBundle&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A (possibly empty) list of the {@link MeterInterval}s to be highlighted
&nbsp;     * on the dial.
&nbsp;     */
&nbsp;    private List&lt;MeterInterval&gt; intervals;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new plot with a default range of {@code 0} to {@code 100} and 
&nbsp;     * no value to display.
&nbsp;     */
&nbsp;    public MeterPlot() {
<b class="fc">&nbsp;        this(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new plot that displays the value from the supplied dataset.
&nbsp;     *
&nbsp;     * @param dataset  the dataset ({@code null} permitted).
&nbsp;     */
&nbsp;    public MeterPlot(ValueDataset dataset) {
<b class="fc">&nbsp;        super();</b>
<b class="fc">&nbsp;        this.shape = DialShape.CIRCLE;</b>
<b class="fc">&nbsp;        this.meterAngle = DEFAULT_METER_ANGLE;</b>
<b class="fc">&nbsp;        this.range = new Range(0.0, 100.0);</b>
<b class="fc">&nbsp;        this.tickSize = 10.0;</b>
<b class="fc">&nbsp;        this.tickPaint = Color.WHITE;</b>
<b class="fc">&nbsp;        this.units = &quot;Units&quot;;</b>
<b class="fc">&nbsp;        this.needlePaint = MeterPlot.DEFAULT_NEEDLE_PAINT;</b>
<b class="fc">&nbsp;        this.tickLabelsVisible = true;</b>
<b class="fc">&nbsp;        this.tickLabelFont = MeterPlot.DEFAULT_LABEL_FONT;</b>
<b class="fc">&nbsp;        this.tickLabelPaint = Color.BLACK;</b>
<b class="fc">&nbsp;        this.tickLabelFormat = NumberFormat.getInstance();</b>
<b class="fc">&nbsp;        this.valueFont = MeterPlot.DEFAULT_VALUE_FONT;</b>
<b class="fc">&nbsp;        this.valuePaint = MeterPlot.DEFAULT_VALUE_PAINT;</b>
<b class="fc">&nbsp;        this.dialBackgroundPaint = MeterPlot.DEFAULT_DIAL_BACKGROUND_PAINT;</b>
<b class="fc">&nbsp;        this.intervals = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        setDataset(dataset);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the dial shape.  The default is {@link DialShape#CIRCLE}).
&nbsp;     *
&nbsp;     * @return The dial shape (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setDialShape(DialShape)
&nbsp;     */
&nbsp;    public DialShape getDialShape() {
<b class="nc">&nbsp;        return this.shape;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the dial shape and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param shape  the shape ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getDialShape()
&nbsp;     */
&nbsp;    public void setDialShape(DialShape shape) {
<b class="fc">&nbsp;        Args.nullNotPermitted(shape, &quot;shape&quot;);</b>
<b class="fc">&nbsp;        this.shape = shape;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the meter angle in degrees.  This defines, in part, the shape
&nbsp;     * of the dial.  The default is 270 degrees.
&nbsp;     *
&nbsp;     * @return The meter angle (in degrees).
&nbsp;     *
&nbsp;     * @see #setMeterAngle(int)
&nbsp;     */
&nbsp;    public int getMeterAngle() {
<b class="nc">&nbsp;        return this.meterAngle;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the angle (in degrees) for the whole range of the dial and sends
&nbsp;     * a {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param angle  the angle (in degrees, in the range 1-360).
&nbsp;     *
&nbsp;     * @see #getMeterAngle()
&nbsp;     */
&nbsp;    public void setMeterAngle(int angle) {
<b class="fc">&nbsp;        if (angle &lt; 1 || angle &gt; 360) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Invalid &#39;angle&#39; (&quot; + angle</b>
&nbsp;                    + &quot;)&quot;);
&nbsp;        }
<b class="fc">&nbsp;        this.meterAngle = angle;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the overall range for the dial.
&nbsp;     *
&nbsp;     * @return The overall range (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setRange(Range)
&nbsp;     */
&nbsp;    public Range getRange() {
<b class="nc">&nbsp;        return this.range;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the range for the dial and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param range  the range ({@code null} not permitted and zero-length
&nbsp;     *               ranges not permitted).
&nbsp;     *
&nbsp;     * @see #getRange()
&nbsp;     */
&nbsp;    public void setRange(Range range) {
<b class="fc">&nbsp;        Args.nullNotPermitted(range, &quot;range&quot;);</b>
<b class="fc">&nbsp;        if (!(range.getLength() &gt; 0.0)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Range length must be positive.&quot;);
&nbsp;        }
<b class="fc">&nbsp;        this.range = range;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the tick size (the interval between ticks on the dial).
&nbsp;     *
&nbsp;     * @return The tick size.
&nbsp;     *
&nbsp;     * @see #setTickSize(double)
&nbsp;     */
&nbsp;    public double getTickSize() {
<b class="nc">&nbsp;        return this.tickSize;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tick size and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param size  the tick size (must be &amp;gt; 0).
&nbsp;     *
&nbsp;     * @see #getTickSize()
&nbsp;     */
&nbsp;    public void setTickSize(double size) {
<b class="fc">&nbsp;        if (size &lt;= 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Requires &#39;size&#39; &gt; 0.&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.tickSize = size;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the paint used to draw the ticks around the dial.
&nbsp;     *
&nbsp;     * @return The paint used to draw the ticks around the dial (never
&nbsp;     *         {@code null}).
&nbsp;     *
&nbsp;     * @see #setTickPaint(Paint)
&nbsp;     */
&nbsp;    public Paint getTickPaint() {
<b class="nc">&nbsp;        return this.tickPaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the paint used to draw the tick labels around the dial and sends
&nbsp;     * a {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getTickPaint()
&nbsp;     */
&nbsp;    public void setTickPaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        this.tickPaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a string describing the units for the dial.
&nbsp;     *
&nbsp;     * @return The units (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #setUnits(String)
&nbsp;     */
&nbsp;    public String getUnits() {
<b class="nc">&nbsp;        return this.units;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the units for the dial and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param units  the units ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getUnits()
&nbsp;     */
&nbsp;    public void setUnits(String units) {
<b class="fc">&nbsp;        this.units = units;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the paint for the needle.
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setNeedlePaint(Paint)
&nbsp;     */
&nbsp;    public Paint getNeedlePaint() {
<b class="nc">&nbsp;        return this.needlePaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the paint used to display the needle and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getNeedlePaint()
&nbsp;     */
&nbsp;    public void setNeedlePaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        this.needlePaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the flag that determines whether or not tick labels are visible.
&nbsp;     *
&nbsp;     * @return The flag.
&nbsp;     *
&nbsp;     * @see #setTickLabelsVisible(boolean)
&nbsp;     */
&nbsp;    public boolean getTickLabelsVisible() {
<b class="nc">&nbsp;        return this.tickLabelsVisible;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the flag that controls whether or not the tick labels are visible
&nbsp;     * and sends a {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param visible  the flag.
&nbsp;     *
&nbsp;     * @see #getTickLabelsVisible()
&nbsp;     */
&nbsp;    public void setTickLabelsVisible(boolean visible) {
<b class="fc">&nbsp;        if (this.tickLabelsVisible != visible) {</b>
<b class="fc">&nbsp;            this.tickLabelsVisible = visible;</b>
<b class="fc">&nbsp;            fireChangeEvent();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the tick label font.
&nbsp;     *
&nbsp;     * @return The font (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setTickLabelFont(Font)
&nbsp;     */
&nbsp;    public Font getTickLabelFont() {
<b class="nc">&nbsp;        return this.tickLabelFont;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tick label font and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param font  the font ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getTickLabelFont()
&nbsp;     */
&nbsp;    public void setTickLabelFont(Font font) {
<b class="fc">&nbsp;        Args.nullNotPermitted(font, &quot;font&quot;);</b>
<b class="fc">&nbsp;        if (!this.tickLabelFont.equals(font)) {</b>
<b class="fc">&nbsp;            this.tickLabelFont = font;</b>
<b class="fc">&nbsp;            fireChangeEvent();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the tick label paint.
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setTickLabelPaint(Paint)
&nbsp;     */
&nbsp;    public Paint getTickLabelPaint() {
<b class="nc">&nbsp;        return this.tickLabelPaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the tick label paint and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getTickLabelPaint()
&nbsp;     */
&nbsp;    public void setTickLabelPaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        if (!this.tickLabelPaint.equals(paint)) {</b>
<b class="fc">&nbsp;            this.tickLabelPaint = paint;</b>
<b class="fc">&nbsp;            fireChangeEvent();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the flag that controls whether or not the value is visible.
&nbsp;     * The default value is {@code true}.
&nbsp;     *
&nbsp;     * @return A flag.
&nbsp;     *
&nbsp;     * @see #setValueVisible
&nbsp;     * @since 1.5.4
&nbsp;     */
&nbsp;    public boolean isValueVisible() {
<b class="nc">&nbsp;        return valueVisible;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Sets the flag that controls whether or not the value is visible
&nbsp;     *  and sends a change event to all registered listeners.
&nbsp;     *
&nbsp;     * @param valueVisible  the new flag value.
&nbsp;     *
&nbsp;     * @see #isValueVisible()
&nbsp;     * @since 1.5.4
&nbsp;     */
&nbsp;    public void setValueVisible(boolean valueVisible) {
<b class="fc">&nbsp;        this.valueVisible = valueVisible;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the tick label format.
&nbsp;     *
&nbsp;     * @return The tick label format (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setTickLabelFormat(NumberFormat)
&nbsp;     */
&nbsp;    public NumberFormat getTickLabelFormat() {
<b class="fc">&nbsp;        return this.tickLabelFormat;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the format for the tick labels and sends a {@link PlotChangeEvent}
&nbsp;     * to all registered listeners.
&nbsp;     *
&nbsp;     * @param format  the format ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getTickLabelFormat()
&nbsp;     */
&nbsp;    public void setTickLabelFormat(NumberFormat format) {
<b class="fc">&nbsp;        Args.nullNotPermitted(format, &quot;format&quot;);</b>
<b class="fc">&nbsp;        this.tickLabelFormat = format;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the font for the value label.
&nbsp;     *
&nbsp;     * @return The font (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setValueFont(Font)
&nbsp;     */
&nbsp;    public Font getValueFont() {
<b class="nc">&nbsp;        return this.valueFont;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the font used to display the value label and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param font  the font ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getValueFont()
&nbsp;     */
&nbsp;    public void setValueFont(Font font) {
<b class="fc">&nbsp;        Args.nullNotPermitted(font, &quot;font&quot;);</b>
<b class="fc">&nbsp;        this.valueFont = font;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the paint for the value label.
&nbsp;     *
&nbsp;     * @return The paint (never {@code null}).
&nbsp;     *
&nbsp;     * @see #setValuePaint(Paint)
&nbsp;     */
&nbsp;    public Paint getValuePaint() {
<b class="nc">&nbsp;        return this.valuePaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the paint used to display the value label and sends a
&nbsp;     * {@link PlotChangeEvent} to all registered listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getValuePaint()
&nbsp;     */
&nbsp;    public void setValuePaint(Paint paint) {
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        this.valuePaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the paint for the dial background.
&nbsp;     *
&nbsp;     * @return The paint (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #setDialBackgroundPaint(Paint)
&nbsp;     */
&nbsp;    public Paint getDialBackgroundPaint() {
<b class="nc">&nbsp;        return this.dialBackgroundPaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the paint used to fill the dial background.  Set this to
&nbsp;     * {@code null} for no background.
&nbsp;     *
&nbsp;     * @param paint  the paint ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getDialBackgroundPaint()
&nbsp;     */
&nbsp;    public void setDialBackgroundPaint(Paint paint) {
<b class="fc">&nbsp;        this.dialBackgroundPaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a flag that controls whether or not a rectangular border is
&nbsp;     * drawn around the plot area.
&nbsp;     *
&nbsp;     * @return A flag.
&nbsp;     *
&nbsp;     * @see #setDrawBorder(boolean)
&nbsp;     */
&nbsp;    public boolean getDrawBorder() {
<b class="fc">&nbsp;        return this.drawBorder;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the flag that controls whether or not a rectangular border is drawn
&nbsp;     * around the plot area and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param draw  the flag.
&nbsp;     *
&nbsp;     * @see #getDrawBorder()
&nbsp;     */
&nbsp;    public void setDrawBorder(boolean draw) {
&nbsp;        // TODO: fix output when this flag is set to true
<b class="fc">&nbsp;        this.drawBorder = draw;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the dial outline paint.
&nbsp;     *
&nbsp;     * @return The paint.
&nbsp;     *
&nbsp;     * @see #setDialOutlinePaint(Paint)
&nbsp;     */
&nbsp;    public Paint getDialOutlinePaint() {
<b class="nc">&nbsp;        return this.dialOutlinePaint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the dial outline paint and sends a {@link PlotChangeEvent} to all
&nbsp;     * registered listeners.
&nbsp;     *
&nbsp;     * @param paint  the paint.
&nbsp;     *
&nbsp;     * @see #getDialOutlinePaint()
&nbsp;     */
&nbsp;    public void setDialOutlinePaint(Paint paint) {
<b class="fc">&nbsp;        this.dialOutlinePaint = paint;</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the dataset for the plot.
&nbsp;     *
&nbsp;     * @return The dataset (possibly {@code null}).
&nbsp;     *
&nbsp;     * @see #setDataset(ValueDataset)
&nbsp;     */
&nbsp;    public ValueDataset getDataset() {
<b class="fc">&nbsp;        return this.dataset;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the dataset for the plot, replacing the existing dataset if there
&nbsp;     * is one, and triggers a {@link PlotChangeEvent}.
&nbsp;     *
&nbsp;     * @param dataset  the dataset ({@code null} permitted).
&nbsp;     *
&nbsp;     * @see #getDataset()
&nbsp;     */
&nbsp;    public void setDataset(ValueDataset dataset) {
&nbsp;
&nbsp;        // if there is an existing dataset, remove the plot from the list of
&nbsp;        // change listeners...
<b class="fc">&nbsp;        ValueDataset existing = this.dataset;</b>
<b class="fc">&nbsp;        if (existing != null) {</b>
<b class="nc">&nbsp;            existing.removeChangeListener(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        // set the new dataset, and register the chart as a change listener...
<b class="fc">&nbsp;        this.dataset = dataset;</b>
<b class="fc">&nbsp;        if (dataset != null) {</b>
<b class="fc">&nbsp;            dataset.addChangeListener(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        // send a dataset change event to self...
<b class="fc">&nbsp;        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);</b>
<b class="fc">&nbsp;        datasetChanged(event);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an unmodifiable list of the intervals for the plot.
&nbsp;     *
&nbsp;     * @return A list.
&nbsp;     *
&nbsp;     * @see #addInterval(MeterInterval)
&nbsp;     */
&nbsp;    public List&lt;MeterInterval&gt; getIntervals() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(intervals);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an interval and sends a {@link PlotChangeEvent} to all registered
&nbsp;     * listeners.
&nbsp;     *
&nbsp;     * @param interval  the interval ({@code null} not permitted).
&nbsp;     *
&nbsp;     * @see #getIntervals()
&nbsp;     * @see #clearIntervals()
&nbsp;     */
&nbsp;    public void addInterval(MeterInterval interval) {
<b class="fc">&nbsp;        Args.nullNotPermitted(interval, &quot;interval&quot;);</b>
<b class="fc">&nbsp;        intervals.add(interval);</b>
<b class="fc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Clears the intervals for the plot and sends a {@link PlotChangeEvent} to
&nbsp;     * all registered listeners.
&nbsp;     *
&nbsp;     * @see #addInterval(MeterInterval)
&nbsp;     */
&nbsp;    public void clearIntervals() {
<b class="nc">&nbsp;        intervals.clear();</b>
<b class="nc">&nbsp;        fireChangeEvent();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an item for each interval.
&nbsp;     *
&nbsp;     * @return A collection of legend items.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public LegendItemCollection getLegendItems() {
<b class="fc">&nbsp;        LegendItemCollection result = new LegendItemCollection();</b>
<b class="fc">&nbsp;        for (MeterInterval mi : intervals) {</b>
<b class="fc">&nbsp;            Paint color = mi.getBackgroundPaint();</b>
<b class="fc">&nbsp;            if (color == null) {</b>
<b class="fc">&nbsp;                color = mi.getOutlinePaint();</b>
&nbsp;            }
<b class="fc">&nbsp;            LegendItem item = new LegendItem(mi.getLabel(), mi.getLabel(),</b>
&nbsp;                    null, null, new Rectangle2D.Double(-4.0, -4.0, 8.0, 8.0),
&nbsp;                    color);
<b class="fc">&nbsp;            item.setDataset(getDataset());</b>
<b class="fc">&nbsp;            result.add(item);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the plot on a Java 2D graphics device (such as the screen or a
&nbsp;     * printer).
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param area  the area within which the plot should be drawn.
&nbsp;     * @param anchor  the anchor point ({@code null} permitted).
&nbsp;     * @param parentState  the state from the parent plot, if there is one.
&nbsp;     * @param info  collects info about the drawing.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
&nbsp;                     PlotState parentState, PlotRenderingInfo info) {
&nbsp;
<b class="fc">&nbsp;        if (info != null) {</b>
<b class="nc">&nbsp;            info.setPlotArea(area);</b>
&nbsp;        }
&nbsp;
&nbsp;        // adjust for insets...
<b class="fc">&nbsp;        RectangleInsets insets = getInsets();</b>
<b class="fc">&nbsp;        insets.trim(area);</b>
&nbsp;
<b class="fc">&nbsp;        area.setRect(area.getX() + 4, area.getY() + 4, area.getWidth() - 8,</b>
<b class="fc">&nbsp;                area.getHeight() - 8);</b>
&nbsp;
&nbsp;        // draw the background
<b class="fc">&nbsp;        if (this.drawBorder) {</b>
<b class="nc">&nbsp;            drawBackground(g2, area);</b>
&nbsp;        }
&nbsp;
&nbsp;        // adjust the plot area by the interior spacing value
<b class="fc">&nbsp;        double gapHorizontal = (2 * DEFAULT_BORDER_SIZE);</b>
<b class="fc">&nbsp;        double gapVertical = (2 * DEFAULT_BORDER_SIZE);</b>
<b class="fc">&nbsp;        double meterX = area.getX() + gapHorizontal / 2;</b>
<b class="fc">&nbsp;        double meterY = area.getY() + gapVertical / 2;</b>
<b class="fc">&nbsp;        double meterW = area.getWidth() - gapHorizontal;</b>
<b class="fc">&nbsp;        double meterH = area.getHeight() - gapVertical</b>
<b class="fc">&nbsp;                + ((this.meterAngle &lt;= 180) &amp;&amp; (this.shape != DialShape.CIRCLE)</b>
<b class="nc">&nbsp;                ? area.getHeight() / 1.25 : 0);</b>
&nbsp;
<b class="fc">&nbsp;        double min = Math.min(meterW, meterH) / 2;</b>
<b class="fc">&nbsp;        meterX = (meterX + meterX + meterW) / 2 - min;</b>
<b class="fc">&nbsp;        meterY = (meterY + meterY + meterH) / 2 - min;</b>
<b class="fc">&nbsp;        meterW = 2 * min;</b>
<b class="fc">&nbsp;        meterH = 2 * min;</b>
&nbsp;
<b class="fc">&nbsp;        Rectangle2D meterArea = new Rectangle2D.Double(meterX, meterY, meterW,</b>
&nbsp;                meterH);
&nbsp;
<b class="fc">&nbsp;        Rectangle2D.Double originalArea = new Rectangle2D.Double(</b>
<b class="fc">&nbsp;                meterArea.getX() - 4, meterArea.getY() - 4,</b>
<b class="fc">&nbsp;                meterArea.getWidth() + 8, meterArea.getHeight() + 8);</b>
&nbsp;
<b class="fc">&nbsp;        double meterMiddleX = meterArea.getCenterX();</b>
<b class="fc">&nbsp;        double meterMiddleY = meterArea.getCenterY();</b>
&nbsp;
&nbsp;        // plot the data (unless the dataset is null)...
<b class="fc">&nbsp;        ValueDataset data = getDataset();</b>
<b class="fc">&nbsp;        if (data != null) {</b>
<b class="fc">&nbsp;            double dataMin = this.range.getLowerBound();</b>
<b class="fc">&nbsp;            double dataMax = this.range.getUpperBound();</b>
&nbsp;
<b class="fc">&nbsp;            Shape savedClip = g2.getClip();</b>
<b class="fc">&nbsp;            g2.clip(originalArea);</b>
<b class="fc">&nbsp;            Composite originalComposite = g2.getComposite();</b>
<b class="fc">&nbsp;            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</b>
<b class="fc">&nbsp;                    getForegroundAlpha()));</b>
&nbsp;
<b class="fc">&nbsp;            if (this.dialBackgroundPaint != null) {</b>
<b class="fc">&nbsp;                fillArc(g2, originalArea, dataMin, dataMax,</b>
&nbsp;                        this.dialBackgroundPaint, true);
&nbsp;            }
<b class="fc">&nbsp;            drawTicks(g2, meterArea, dataMin, dataMax);</b>
<b class="fc">&nbsp;            drawArcForInterval(g2, meterArea, new MeterInterval(&quot;&quot;, this.range,</b>
&nbsp;                    this.dialOutlinePaint, new BasicStroke(1.0f), null));
&nbsp;
<b class="fc">&nbsp;            for (MeterInterval interval : this.intervals) {</b>
<b class="fc">&nbsp;                drawArcForInterval(g2, meterArea, interval);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            Number n = data.getValue();</b>
<b class="fc">&nbsp;            if (n != null) {</b>
<b class="fc">&nbsp;                double value = n.doubleValue();</b>
<b class="fc">&nbsp;                drawValueLabel(g2, meterArea);</b>
&nbsp;
<b class="fc">&nbsp;                if (this.range.contains(value)) {</b>
<b class="fc">&nbsp;                    g2.setPaint(this.needlePaint);</b>
<b class="fc">&nbsp;                    g2.setStroke(new BasicStroke(2.0f));</b>
&nbsp;
<b class="fc">&nbsp;                    double radius = (meterArea.getWidth() / 2)</b>
&nbsp;                                    + DEFAULT_BORDER_SIZE + 15;
<b class="fc">&nbsp;                    double valueAngle = valueToAngle(value);</b>
<b class="fc">&nbsp;                    double valueP1 = meterMiddleX</b>
<b class="fc">&nbsp;                            + (radius * Math.cos(Math.PI * (valueAngle / 180)));</b>
<b class="fc">&nbsp;                    double valueP2 = meterMiddleY</b>
<b class="fc">&nbsp;                            - (radius * Math.sin(Math.PI * (valueAngle / 180)));</b>
&nbsp;
<b class="fc">&nbsp;                    Polygon arrow = new Polygon();</b>
<b class="fc">&nbsp;                    if ((valueAngle &gt; 135 &amp;&amp; valueAngle &lt; 225)</b>
&nbsp;                        || (valueAngle &lt; 45 &amp;&amp; valueAngle &gt; -45)) {
&nbsp;
<b class="nc">&nbsp;                        double valueP3 = (meterMiddleY</b>
&nbsp;                                - DEFAULT_CIRCLE_SIZE / 4);
<b class="nc">&nbsp;                        double valueP4 = (meterMiddleY</b>
&nbsp;                                + DEFAULT_CIRCLE_SIZE / 4);
<b class="nc">&nbsp;                        arrow.addPoint((int) meterMiddleX, (int) valueP3);</b>
<b class="nc">&nbsp;                        arrow.addPoint((int) meterMiddleX, (int) valueP4);</b>
&nbsp;
<b class="nc">&nbsp;                    }</b>
&nbsp;                    else {
<b class="fc">&nbsp;                        arrow.addPoint((int) (meterMiddleX</b>
&nbsp;                                - DEFAULT_CIRCLE_SIZE / 4), (int) meterMiddleY);
<b class="fc">&nbsp;                        arrow.addPoint((int) (meterMiddleX</b>
&nbsp;                                + DEFAULT_CIRCLE_SIZE / 4), (int) meterMiddleY);
&nbsp;                    }
<b class="fc">&nbsp;                    arrow.addPoint((int) valueP1, (int) valueP2);</b>
<b class="fc">&nbsp;                    g2.fill(arrow);</b>
&nbsp;
<b class="fc">&nbsp;                    Ellipse2D circle = new Ellipse2D.Double(meterMiddleX</b>
&nbsp;                            - DEFAULT_CIRCLE_SIZE / 2, meterMiddleY
&nbsp;                            - DEFAULT_CIRCLE_SIZE / 2, DEFAULT_CIRCLE_SIZE,
&nbsp;                            DEFAULT_CIRCLE_SIZE);
<b class="fc">&nbsp;                    g2.fill(circle);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            g2.setClip(savedClip);</b>
<b class="fc">&nbsp;            g2.setComposite(originalComposite);</b>
&nbsp;
&nbsp;        }
<b class="fc">&nbsp;        if (this.drawBorder) {</b>
<b class="nc">&nbsp;            drawOutline(g2, area);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the arc to represent an interval.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param meterArea  the drawing area.
&nbsp;     * @param interval  the interval.
&nbsp;     */
&nbsp;    protected void drawArcForInterval(Graphics2D g2, Rectangle2D meterArea,
&nbsp;                                      MeterInterval interval) {
&nbsp;
<b class="fc">&nbsp;        double minValue = interval.getRange().getLowerBound();</b>
<b class="fc">&nbsp;        double maxValue = interval.getRange().getUpperBound();</b>
<b class="fc">&nbsp;        Paint outlinePaint = interval.getOutlinePaint();</b>
<b class="fc">&nbsp;        Stroke outlineStroke = interval.getOutlineStroke();</b>
<b class="fc">&nbsp;        Paint backgroundPaint = interval.getBackgroundPaint();</b>
&nbsp;
<b class="fc">&nbsp;        if (backgroundPaint != null) {</b>
<b class="nc">&nbsp;            fillArc(g2, meterArea, minValue, maxValue, backgroundPaint, false);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (outlinePaint != null) {</b>
<b class="fc">&nbsp;            if (outlineStroke != null) {</b>
<b class="fc">&nbsp;                drawArc(g2, meterArea, minValue, maxValue, outlinePaint,</b>
&nbsp;                        outlineStroke);
&nbsp;            }
<b class="fc">&nbsp;            drawTick(g2, meterArea, minValue, true);</b>
<b class="fc">&nbsp;            drawTick(g2, meterArea, maxValue, true);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws an arc.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param area  the plot area.
&nbsp;     * @param minValue  the minimum value.
&nbsp;     * @param maxValue  the maximum value.
&nbsp;     * @param paint  the paint.
&nbsp;     * @param stroke  the stroke.
&nbsp;     */
&nbsp;    protected void drawArc(Graphics2D g2, Rectangle2D area, double minValue,
&nbsp;                           double maxValue, Paint paint, Stroke stroke) {
&nbsp;
<b class="fc">&nbsp;        double startAngle = valueToAngle(maxValue);</b>
<b class="fc">&nbsp;        double endAngle = valueToAngle(minValue);</b>
<b class="fc">&nbsp;        double extent = endAngle - startAngle;</b>
&nbsp;
<b class="fc">&nbsp;        double x = area.getX();</b>
<b class="fc">&nbsp;        double y = area.getY();</b>
<b class="fc">&nbsp;        double w = area.getWidth();</b>
<b class="fc">&nbsp;        double h = area.getHeight();</b>
<b class="fc">&nbsp;        g2.setPaint(paint);</b>
<b class="fc">&nbsp;        g2.setStroke(stroke);</b>
&nbsp;
<b class="fc">&nbsp;        if (paint != null &amp;&amp; stroke != null) {</b>
<b class="fc">&nbsp;            Arc2D.Double arc = new Arc2D.Double(x, y, w, h, startAngle,</b>
&nbsp;                    extent, Arc2D.OPEN);
<b class="fc">&nbsp;            g2.setPaint(paint);</b>
<b class="fc">&nbsp;            g2.setStroke(stroke);</b>
<b class="fc">&nbsp;            g2.draw(arc);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fills an arc on the dial between the given values.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param area  the plot area.
&nbsp;     * @param minValue  the minimum data value.
&nbsp;     * @param maxValue  the maximum data value.
&nbsp;     * @param paint  the background paint ({@code null} not permitted).
&nbsp;     * @param dial  a flag that indicates whether the arc represents the whole
&nbsp;     *              dial.
&nbsp;     */
&nbsp;    protected void fillArc(Graphics2D g2, Rectangle2D area,
&nbsp;            double minValue, double maxValue, Paint paint, boolean dial) {
&nbsp;
<b class="fc">&nbsp;        Args.nullNotPermitted(paint, &quot;paint&quot;);</b>
<b class="fc">&nbsp;        double startAngle = valueToAngle(maxValue);</b>
<b class="fc">&nbsp;        double endAngle = valueToAngle(minValue);</b>
<b class="fc">&nbsp;        double extent = endAngle - startAngle;</b>
&nbsp;
<b class="fc">&nbsp;        double x = area.getX();</b>
<b class="fc">&nbsp;        double y = area.getY();</b>
<b class="fc">&nbsp;        double w = area.getWidth();</b>
<b class="fc">&nbsp;        double h = area.getHeight();</b>
<b class="fc">&nbsp;        int joinType = Arc2D.OPEN;</b>
<b class="fc">&nbsp;        if (this.shape == DialShape.PIE) {</b>
<b class="nc">&nbsp;            joinType = Arc2D.PIE;</b>
&nbsp;        }
<b class="fc">&nbsp;        else if (this.shape == DialShape.CHORD) {</b>
<b class="nc">&nbsp;            if (dial &amp;&amp; this.meterAngle &gt; 180) {</b>
<b class="nc">&nbsp;                joinType = Arc2D.CHORD;</b>
&nbsp;            }
&nbsp;            else {
<b class="nc">&nbsp;                joinType = Arc2D.PIE;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        else if (this.shape == DialShape.CIRCLE) {</b>
<b class="fc">&nbsp;            joinType = Arc2D.PIE;</b>
<b class="fc">&nbsp;            if (dial) {</b>
<b class="fc">&nbsp;                extent = 360;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;DialShape not recognised.&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        g2.setPaint(paint);</b>
<b class="fc">&nbsp;        Arc2D.Double arc = new Arc2D.Double(x, y, w, h, startAngle, extent,</b>
&nbsp;                joinType);
<b class="fc">&nbsp;        g2.fill(arc);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Translates a data value to an angle on the dial.
&nbsp;     *
&nbsp;     * @param value  the value.
&nbsp;     *
&nbsp;     * @return The angle on the dial.
&nbsp;     */
&nbsp;    public double valueToAngle(double value) {
<b class="fc">&nbsp;        value = value - this.range.getLowerBound();</b>
<b class="fc">&nbsp;        double baseAngle = 180 + ((this.meterAngle - 180) / 2.0);</b>
<b class="fc">&nbsp;        return baseAngle - ((value / this.range.getLength()) * this.meterAngle);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the ticks that subdivide the overall range.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param meterArea  the meter area.
&nbsp;     * @param minValue  the minimum value.
&nbsp;     * @param maxValue  the maximum value.
&nbsp;     */
&nbsp;    protected void drawTicks(Graphics2D g2, Rectangle2D meterArea,
&nbsp;                             double minValue, double maxValue) {
<b class="fc">&nbsp;        for (double v = minValue; v &lt;= maxValue; v += this.tickSize) {</b>
<b class="fc">&nbsp;            drawTick(g2, meterArea, v);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a tick.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param meterArea  the meter area.
&nbsp;     * @param value  the value.
&nbsp;     */
&nbsp;    protected void drawTick(Graphics2D g2, Rectangle2D meterArea,
&nbsp;            double value) {
<b class="fc">&nbsp;        drawTick(g2, meterArea, value, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a tick on the dial.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param meterArea  the meter area.
&nbsp;     * @param value  the tick value.
&nbsp;     * @param label  a flag that controls whether or not a value label is drawn.
&nbsp;     */
&nbsp;    protected void drawTick(Graphics2D g2, Rectangle2D meterArea,
&nbsp;                            double value, boolean label) {
&nbsp;
<b class="fc">&nbsp;        double valueAngle = valueToAngle(value);</b>
&nbsp;
<b class="fc">&nbsp;        double meterMiddleX = meterArea.getCenterX();</b>
<b class="fc">&nbsp;        double meterMiddleY = meterArea.getCenterY();</b>
&nbsp;
<b class="fc">&nbsp;        g2.setPaint(this.tickPaint);</b>
<b class="fc">&nbsp;        g2.setStroke(new BasicStroke(2.0f));</b>
&nbsp;
&nbsp;        double valueP2X;
&nbsp;        double valueP2Y;
&nbsp;
<b class="fc">&nbsp;        double radius = (meterArea.getWidth() / 2) + DEFAULT_BORDER_SIZE;</b>
<b class="fc">&nbsp;        double radius1 = radius - 15;</b>
&nbsp;
<b class="fc">&nbsp;        double valueP1X = meterMiddleX</b>
<b class="fc">&nbsp;                + (radius * Math.cos(Math.PI * (valueAngle / 180)));</b>
<b class="fc">&nbsp;        double valueP1Y = meterMiddleY</b>
<b class="fc">&nbsp;                - (radius * Math.sin(Math.PI * (valueAngle / 180)));</b>
&nbsp;
<b class="fc">&nbsp;        valueP2X = meterMiddleX</b>
<b class="fc">&nbsp;                + (radius1 * Math.cos(Math.PI * (valueAngle / 180)));</b>
<b class="fc">&nbsp;        valueP2Y = meterMiddleY</b>
<b class="fc">&nbsp;                - (radius1 * Math.sin(Math.PI * (valueAngle / 180)));</b>
&nbsp;
<b class="fc">&nbsp;        Line2D.Double line = new Line2D.Double(valueP1X, valueP1Y, valueP2X,</b>
&nbsp;                valueP2Y);
<b class="fc">&nbsp;        g2.draw(line);</b>
&nbsp;
<b class="fc">&nbsp;        if (this.tickLabelsVisible &amp;&amp; label) {</b>
&nbsp;
<b class="fc">&nbsp;            String tickLabel =  this.tickLabelFormat.format(value);</b>
<b class="fc">&nbsp;            g2.setFont(this.tickLabelFont);</b>
<b class="fc">&nbsp;            g2.setPaint(this.tickLabelPaint);</b>
&nbsp;
<b class="fc">&nbsp;            FontMetrics fm = g2.getFontMetrics();</b>
<b class="fc">&nbsp;            Rectangle2D tickLabelBounds</b>
<b class="fc">&nbsp;                = TextUtils.getTextBounds(tickLabel, g2, fm);</b>
&nbsp;
<b class="fc">&nbsp;            double x = valueP2X;</b>
<b class="fc">&nbsp;            double y = valueP2Y;</b>
<b class="fc">&nbsp;            if (valueAngle == 90 || valueAngle == 270) {</b>
<b class="nc">&nbsp;                x = x - tickLabelBounds.getWidth() / 2;</b>
&nbsp;            }
<b class="fc">&nbsp;            else if (valueAngle &lt; 90 || valueAngle &gt; 270) {</b>
<b class="fc">&nbsp;                x = x - tickLabelBounds.getWidth();</b>
&nbsp;            }
<b class="fc">&nbsp;            if ((valueAngle &gt; 135 &amp;&amp; valueAngle &lt; 225)</b>
&nbsp;                    || valueAngle &gt; 315 || valueAngle &lt; 45) {
<b class="fc">&nbsp;                y = y - tickLabelBounds.getHeight() / 2;</b>
&nbsp;            }
&nbsp;            else {
<b class="fc">&nbsp;                y = y + tickLabelBounds.getHeight() / 2;</b>
&nbsp;            }
<b class="fc">&nbsp;            g2.drawString(tickLabel, (float) x, (float) y);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws the value label just below the center of the dial.
&nbsp;     *
&nbsp;     * @param g2  the graphics device.
&nbsp;     * @param area  the plot area.
&nbsp;     */
&nbsp;    protected void drawValueLabel(Graphics2D g2, Rectangle2D area) {
<b class="fc">&nbsp;        if (valueVisible) {</b>
<b class="fc">&nbsp;            g2.setFont(this.valueFont);</b>
<b class="fc">&nbsp;            g2.setPaint(this.valuePaint);</b>
<b class="fc">&nbsp;            String valueStr = &quot;No value&quot;;</b>
<b class="fc">&nbsp;            if (this.dataset != null) {</b>
<b class="fc">&nbsp;                Number n = this.dataset.getValue();</b>
<b class="fc">&nbsp;                if (n != null) {</b>
<b class="fc">&nbsp;                    valueStr = this.tickLabelFormat.format(n.doubleValue()) + &quot; &quot;</b>
&nbsp;                        + this.units;
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            float x = (float) area.getCenterX();</b>
<b class="fc">&nbsp;            float y = (float) area.getCenterY() + DEFAULT_CIRCLE_SIZE;</b>
<b class="fc">&nbsp;            TextUtils.drawAlignedString(valueStr, g2, x, y,</b>
&nbsp;                TextAnchor.TOP_CENTER);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a short string describing the type of plot.
&nbsp;     *
&nbsp;     * @return A string describing the type of plot.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getPlotType() {
<b class="nc">&nbsp;        return localizationResources.getString(&quot;Meter_Plot&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A zoom method that does nothing.  Plots are required to support the
&nbsp;     * zoom operation.  In the case of a meter plot, it doesn&#39;t make sense to
&nbsp;     * zoom in or out, so the method is empty.
&nbsp;     *
&nbsp;     * @param percent   The zoom percentage.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void zoom(double percent) {
&nbsp;        // intentionally blank
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tests the plot for equality with an arbitrary object.  Note that the
&nbsp;     * dataset is ignored for the purposes of testing equality.
&nbsp;     *
&nbsp;     * @param obj  the object ({@code null} permitted).
&nbsp;     *
&nbsp;     * @return A boolean.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean equals(Object obj) {
<b class="fc">&nbsp;        if (obj == this) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!(obj instanceof MeterPlot)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!super.equals(obj)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        MeterPlot that = (MeterPlot) obj;</b>
<b class="fc">&nbsp;        if (!Objects.equals(this.units, that.units)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.range, that.range)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.intervals, that.intervals)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.dialOutlinePaint,</b>
&nbsp;                that.dialOutlinePaint)) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.shape != that.shape) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.dialBackgroundPaint,</b>
&nbsp;                that.dialBackgroundPaint)) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.needlePaint, that.needlePaint)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.valueVisible != that.valueVisible) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.valueFont, that.valueFont)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.valuePaint, that.valuePaint)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.tickPaint, that.tickPaint)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.tickSize != that.tickSize) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.tickLabelsVisible != that.tickLabelsVisible) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.tickLabelFont, that.tickLabelFont)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!PaintUtils.equal(this.tickLabelPaint, that.tickLabelPaint)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!Objects.equals(this.tickLabelFormat, that.tickLabelFormat)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.drawBorder != that.drawBorder) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.meterAngle != that.meterAngle) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Provides serialization support.
&nbsp;     *
&nbsp;     * @param stream  the output stream.
&nbsp;     *
&nbsp;     * @throws IOException  if there is an I/O error.
&nbsp;     */
&nbsp;    private void writeObject(ObjectOutputStream stream) throws IOException {
<b class="fc">&nbsp;        stream.defaultWriteObject();</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.dialBackgroundPaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.dialOutlinePaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.needlePaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.valuePaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.tickPaint, stream);</b>
<b class="fc">&nbsp;        SerialUtils.writePaint(this.tickLabelPaint, stream);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Provides serialization support.
&nbsp;     *
&nbsp;     * @param stream  the input stream.
&nbsp;     *
&nbsp;     * @throws IOException  if there is an I/O error.
&nbsp;     * @throws ClassNotFoundException  if there is a classpath problem.
&nbsp;     */
&nbsp;    private void readObject(ObjectInputStream stream)
&nbsp;        throws IOException, ClassNotFoundException {
<b class="fc">&nbsp;        stream.defaultReadObject();</b>
<b class="fc">&nbsp;        this.dialBackgroundPaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.dialOutlinePaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.needlePaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.valuePaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.tickPaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        this.tickLabelPaint = SerialUtils.readPaint(stream);</b>
<b class="fc">&nbsp;        if (this.dataset != null) {</b>
<b class="fc">&nbsp;            this.dataset.addChangeListener(this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an independent copy (clone) of the plot.  The dataset is NOT
&nbsp;     * cloned - both the original and the clone will have a reference to the
&nbsp;     * same dataset.
&nbsp;     *
&nbsp;     * @return A clone.
&nbsp;     *
&nbsp;     * @throws CloneNotSupportedException if some component of the plot cannot
&nbsp;     *         be cloned.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Object clone() throws CloneNotSupportedException {
<b class="fc">&nbsp;        MeterPlot clone = (MeterPlot) super.clone();</b>
<b class="fc">&nbsp;        clone.tickLabelFormat = (NumberFormat) this.tickLabelFormat.clone();</b>
&nbsp;        // the following relies on the fact that the intervals are immutable
<b class="fc">&nbsp;        clone.intervals = new ArrayList&lt;&gt;(this.intervals);</b>
<b class="fc">&nbsp;        if (clone.dataset != null) {</b>
<b class="nc">&nbsp;            clone.dataset.addChangeListener(clone);</b>
&nbsp;        }
<b class="fc">&nbsp;        return clone;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-10-20 10:57</div>
</div>
</body>
</html>
